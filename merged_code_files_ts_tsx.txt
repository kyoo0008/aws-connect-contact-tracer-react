---------------------
/Users/ke-aicc/Downloads/files/src/index.tsx
---------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


---------------------
/Users/ke-aicc/Downloads/files/src/App.tsx
---------------------
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';

// Pages
import Dashboard from './pages/Dashboard';
import ContactFlowViewer from './pages/ContactFlowViewer';
import FlowDetailViewer from './pages/FlowDetailViewer';
import ModuleDetailViewer from './pages/ModuleDetailViewer';
import LogAnalysis from './pages/LogAnalysis';
import Settings from './pages/Settings';
import XRayTraceViewer from './pages/XRayTraceViewer';

// Components
import Layout from './components/Layout/Layout';
import ErrorBoundary from './components/ErrorBoundary/ErrorBoundary';

// Contexts
import { AuthProvider } from './contexts/AuthContext';
import { ConfigProvider } from './contexts/ConfigContext';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes
      retry: 3,
      refetchOnWindowFocus: false,
    },
  },
});

const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#FF9900', // AWS Orange
      light: '#FFB84D',
      dark: '#CC7A00',
    },
    secondary: {
      main: '#232F3E', // AWS Dark Blue
      light: '#37475A',
      dark: '#161E2D',
    },
    background: {
      default: '#F5F5F5',
      paper: '#FFFFFF',
    },
    error: {
      main: '#D13212',
    },
    success: {
      main: '#037F0C',
    },
    info: {
      main: '#0073BB',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2rem',
      fontWeight: 600,
    },
    h2: {
      fontSize: '1.5rem',
      fontWeight: 500,
    },
    h3: {
      fontSize: '1.25rem',
      fontWeight: 500,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 4,
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        },
      },
    },
  },
});

function App() {
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <LocalizationProvider dateAdapter={AdapterDayjs}>
            <AuthProvider>
              <ConfigProvider>
                <Router>
                  <Layout>
                    <Routes>
                      <Route path="/" element={<Dashboard />} />
                      <Route path="/contact-flow/:contactId?" element={<ContactFlowViewer />} />
                      <Route path="/contact-flow/:contactId/flow/:flowName" element={<FlowDetailViewer />} />
                      <Route path="/contact-flow/:contactId/flow/:flowName/module/:moduleName" element={<ModuleDetailViewer />} />
                      <Route path="/logs/:contactId?" element={<LogAnalysis />} />
                      <Route path="/xray-trace" element={<XRayTraceViewer />} />
                      <Route path="/settings" element={<Settings />} />
                    </Routes>
                  </Layout>
                </Router>
              </ConfigProvider>
            </AuthProvider>
          </LocalizationProvider>
        </ThemeProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  );
}

export default App;


---------------------
/Users/ke-aicc/Downloads/files/src/reportWebVitals.ts
---------------------
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


---------------------
/Users/ke-aicc/Downloads/files/src/types/contact.types.ts
---------------------
import { Position } from 'react-flow-renderer';

// AWS Connect Contact Flow Types

export interface ContactLog {
  ContactId: string;
  ContactFlowId: string;
  ContactFlowName: string;
  ContactFlowModuleType: string;
  Timestamp: string;
  Parameters?: Record<string, any>;
  Results?: string;
  ExternalResults?: Record<string, any>;
  Identifier?: string;
  node_id?: string;
  InitiationTimestamp?: string;
  DisconnectTimestamp?: string;
  Channel?: string;
  QueueName?: string;
  AgentName?: string;
  Duration?: number;
  xray_trace_id?: string;
  ModuleExecutionStack?: string[];
}

export interface LambdaLog {
  timestamp: string;
  ContactId: string;
  service: string;
  message?: string;
  level?: string;
  error?: any;
  request?: any;
  response?: any;
  duration?: number;
  xrayTraceId?: string;
}

export interface ContactFlowNode {
  id: string;
  type: string;
  data: {
    label: string;
    moduleType: string;
    parameters?: Record<string, any>;
    results?: string;
    error?: boolean;
    timestamp?: string;
    duration?: number;
    chunkedLogs?: ContactLog[];
    timeRange?: {
      start: string;
      end: string;
    };
    logCount?: number;
    sourcePosition?: Position;
    targetPosition?: Position;
  };
  position: {
    x: number;
    y: number;
  };
  style?: Record<string, any>;
}

export interface ContactFlowEdge {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string;
  targetHandle?: string;
  label?: string;
  type?: string;
  animated?: boolean;
  style?: Record<string, any>;
}

export interface ContactFlowData {
  nodes: ContactFlowNode[];
  edges: ContactFlowEdge[];
  logs: ContactLog[];
  lambdaLogs?: Record<string, LambdaLog[]>;
  transcript?: TranscriptEntry[];
}

export interface TranscriptEntry {
  Id: string;
  ParticipantId: string;
  ParticipantRole: 'AGENT' | 'CUSTOMER' | 'SYSTEM';
  Content: string;
  ContentType: string;
  DisplayName?: string;
  AbsoluteTime?: string;
  Sentiment?: string;
  IssuesDetected?: any[];
}

export interface ContactDetails {
  contactId: string;
  instanceId: string;
  initiationTimestamp: string;
  disconnectTimestamp?: string;
  channel: string;
  queueName?: string;
  agentName?: string;
  duration?: number;
  attributes?: Record<string, any>;
  tags?: Record<string, string>;
  recordings?: Recording[];
  contactFlowName?: string;
}

export interface Recording {
  recordingId: string;
  location: string;
  startTime: string;
  stopTime: string;
  type: 'AUDIO' | 'SCREEN' | 'BOTH';
  status: 'AVAILABLE' | 'PROCESSING' | 'DELETED';
}

export interface FlowModule {
  id: string;
  name: string;
  type: string;
  description?: string;
  parameters?: Record<string, any>;
  actions?: FlowAction[];
  metadata?: Record<string, any>;
}

export interface FlowAction {
  id: string;
  type: string;
  parameters: Record<string, any>;
  transitions?: Record<string, string>;
  errors?: string[];
}

export interface SearchCriteria {
  contactId?: string;
  instanceId?: string;
  startTime?: Date;
  endTime?: Date;
  channel?: string[];
  queueName?: string;
  agentName?: string;
  phoneNumber?: string;
  flowName?: string;
}

export interface AWSConfig {
  region: string;
  instanceId: string;
  environment: 'dev' | 'stg' | 'prd' | 'test';
  logGroupName: string;
  s3BucketPrefix: string;
  credentials?: {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken?: string;
    expiration?: string;
  };
  profile?: string; // AWS SSO profile name (for backend API)
}

export interface FlowStatistics {
  totalContacts: number;
  averageDuration: number;
  errorRate: number;
  abandonRate: number;
  transferRate: number;
  moduleUsage: Record<string, number>;
  timeDistribution: TimeDistribution[];
}

export interface TimeDistribution {
  timestamp: string;
  count: number;
  errors: number;
  duration: number;
}

export type ModuleType =
  | 'SetLoggingBehavior'
  | 'SetAttributes'
  | 'SetFlowAttributes'
  | 'PlayPrompt'
  | 'GetUserInput'
  | 'StoreUserInput'
  | 'InvokeExternalResource'
  | 'InvokeLambdaFunction'
  | 'CheckAttribute'
  | 'Transfer'
  | 'TransferToQueue'
  | 'TransferToFlow'
  | 'Disconnect'
  | 'Wait'
  | 'Loop'
  | 'SetContactFlow'
  | 'SetWhisperFlow'
  | 'SetHoldFlow'
  | 'SetCustomerQueueFlow'
  | 'SetEventHook'
  | 'GetCustomerProfile'
  | 'AssociateContactToCustomerProfile'
  | 'TagContact'
  | 'InvokeFlowModule'
  | 'ReturnFromFlowModule'
  | 'Resume'
  | 'Dial';

export interface FlowError {
  timestamp: string;
  moduleType: string;
  blockId?: string;
  error: string;
  details?: any;
  contactId: string;
}

export interface FlowMetrics {
  successRate: number;
  averageHandleTime: number;
  customerSatisfaction?: number;
  firstCallResolution?: number;
  agentUtilization?: number;
}

// API Response Types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: string;
}

export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}


---------------------
/Users/ke-aicc/Downloads/files/src/contexts/ConfigContext.tsx
---------------------
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { AWSConfig } from '@/types/contact.types';

interface ConfigContextType {
  config: AWSConfig;
  updateConfig: (updates: Partial<AWSConfig>) => void;
  resetConfig: () => void;
  isConfigured: boolean;
}

const DEFAULT_CONFIG: AWSConfig = {
  region: 'ap-northeast-2',
  instanceId: '',
  environment: 'prd',
  logGroupName: '/aws/connect/kal-servicecenter',
  s3BucketPrefix: 'aicc', // Kept for backward compatibility but will be removed from UI
};

const ConfigContext = createContext<ConfigContextType | undefined>(undefined);

export const useConfig = () => {
  const context = useContext(ConfigContext);
  if (!context) {
    throw new Error('useConfig must be used within a ConfigProvider');
  }
  return context;
};

interface ConfigProviderProps {
  children: ReactNode;
}

export const ConfigProvider: React.FC<ConfigProviderProps> = ({ children }) => {
  const [config, setConfig] = useState<AWSConfig>(() => {
    // Load config from localStorage
    const stored = localStorage.getItem('aws_config');
    if (stored) {
      try {
        return { ...DEFAULT_CONFIG, ...JSON.parse(stored) };
      } catch {
        return DEFAULT_CONFIG;
      }
    }
    return DEFAULT_CONFIG;
  });

  useEffect(() => {
    // Save config to localStorage whenever it changes
    localStorage.setItem('aws_config', JSON.stringify(config));
  }, [config]);

  const updateConfig = (updates: Partial<AWSConfig>) => {
    setConfig(prev => ({
      ...prev,
      ...updates,
    }));
  };

  const resetConfig = () => {
    setConfig(DEFAULT_CONFIG);
    localStorage.removeItem('aws_config');
  };

  const isConfigured = !!(
    config.instanceId &&
    config.region &&
    config.environment
  );

  const value: ConfigContextType = {
    config,
    updateConfig,
    resetConfig,
    isConfigured,
  };

  return (
    <ConfigContext.Provider value={value}>
      {children}
    </ConfigContext.Provider>
  );
};

export default ConfigContext;


---------------------
/Users/ke-aicc/Downloads/files/src/contexts/AuthContext.tsx
---------------------
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { AWSConfig } from '@/types/contact.types';

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
  awsCredentials?: {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken?: string;
  };
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  updateCredentials: (credentials: Partial<AWSConfig['credentials']>) => void;
}

interface LoginCredentials {
  email: string;
  password: string;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for stored auth token
    const checkAuth = async () => {
      try {
        const storedAuth = localStorage.getItem('auth_token');
        const storedUser = localStorage.getItem('user_data');
        
        if (storedAuth && storedUser) {
          const userData = JSON.parse(storedUser);
          setUser(userData);
        }
      } catch (error) {
        console.error('Error checking authentication:', error);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (credentials: LoginCredentials) => {
    try {
      // In production, this would be an API call
      // For demo purposes, we'll simulate a login
      const mockUser: User = {
        id: '1',
        name: credentials.email.split('@')[0],
        email: credentials.email,
        role: 'admin',
      };

      // Store auth data
      localStorage.setItem('auth_token', 'mock_token_' + Date.now());
      localStorage.setItem('user_data', JSON.stringify(mockUser));
      
      setUser(mockUser);
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('auth_token');
    localStorage.removeItem('user_data');
    setUser(null);
  };

  const updateCredentials = (credentials: Partial<AWSConfig['credentials']>) => {
    if (user) {
      setUser({
        ...user,
        awsCredentials: {
          ...user.awsCredentials,
          ...credentials,
        } as any,
      });
    }
  };

  const value: AuthContextType = {
    user,
    isAuthenticated: !!user,
    isLoading,
    login,
    logout,
    updateCredentials,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export default AuthContext;


---------------------
/Users/ke-aicc/Downloads/files/src/utils/logProcessor.ts
---------------------
import { ContactLog, AWSConfig } from '@/types/contact.types';
import { getFlowDefinitionService } from '@/services/flowDefinitionService';

/**
 * CheckAttribute 로그에 Flow Definition 데이터를 추가하여 비교값을 enrichment 합니다
 * 최적화: 각 unique flow/module definition은 한 번만 fetch합니다
 */
export const enrichCheckAttributeLogs = async (
  logs: ContactLog[],
  config: AWSConfig
): Promise<ContactLog[]> => {
  const flowDefService = getFlowDefinitionService(config);

  // Step 1: 모든 CheckAttribute 로그에서 unique flow IDs 추출
  const uniqueFlowIds = new Set<string>();
  const checkAttributeLogs: ContactLog[] = [];

  logs.forEach((log) => {
    if (log.ContactFlowModuleType === 'CheckAttribute' && log.Identifier && log.ContactFlowId) {
      uniqueFlowIds.add(log.ContactFlowId);
      checkAttributeLogs.push(log);
    }
  });

  // Step 2: 모든 unique flow definitions을 한 번씩만 fetch (병렬 처리)
  const flowDefinitionPromises = Array.from(uniqueFlowIds).map(async (flowId) => {
    try {
      await flowDefService.getFlowDefinitionByArn(flowId);
    } catch (error) {
      console.error(`Error fetching flow definition for ${flowId}:`, error);
    }
  });

  // 모든 flow definitions이 cache에 로드될 때까지 대기
  await Promise.all(flowDefinitionPromises);

  // Step 3: 이제 cache에서 데이터를 가져와 logs를 enrichment
  const enrichedLogs = logs.map((log) => {
    // CheckAttribute가 아니면 그대로 반환
    if (log.ContactFlowModuleType !== 'CheckAttribute') {
      return log;
    }

    // Identifier와 ContactFlowId가 없으면 enrichment 불가
    if (!log.Identifier || !log.ContactFlowId) {
      return log;
    }

    try {
      // Cache에서 가져오기 (동기적으로 처리 가능 - 이미 cache됨)
      // getComparisonValue는 내부적으로 cache된 flow definition을 사용
      const comparisonValuePromise = flowDefService.getComparisonValue(
        log.ContactFlowId,
        log.Identifier,
        'ComparisonValue',
        false
      );

      const comparisonSecondValuePromise = flowDefService.getComparisonValue(
        log.ContactFlowId,
        log.Identifier,
        'ComparisonValue',
        true
      );

      // 비동기 처리를 위해 Promise 반환
      return Promise.all([comparisonValuePromise, comparisonSecondValuePromise]).then(
        ([comparisonValue, comparisonSecondValue]) => {
          // Parameters에 flow definition 정보 추가
          if (comparisonValue || comparisonSecondValue) {
            return {
              ...log,
              Parameters: {
                ...log.Parameters,
                _comparisonValue: comparisonValue,
                _comparisonSecondValue: comparisonSecondValue,
              },
            };
          }
          return log;
        }
      );
    } catch (error) {
      console.error('Error enriching CheckAttribute log:', error);
      return log;
    }
  });

  // Step 4: 모든 enrichment 완료 대기
  return Promise.all(enrichedLogs);
};

/**
 * CheckAttribute 로그 병합 시 각 파라미터에 enrichment 데이터도 병합합니다
 * 이 함수는 이미 enriched된 로그를 처리한 후 병합할 때 사용됩니다
 */
export const preserveEnrichmentInMerge = (logs: ContactLog[]): any[] => {
  return logs.map(log => ({
    ...log.Parameters,
    Results: log.Results,
    _comparisonValue: log.Parameters?._comparisonValue,
    _comparisonSecondValue: log.Parameters?._comparisonSecondValue,
  }));
};

// 헬퍼 함수: 상세 뷰를 위해 로그를 처리합니다.
// 모듈 로그를 청킹하고 SetAttributes 로그를 병합하는 로직을 통합합니다.
export const processLogsForDetailView = (logs: ContactLog[]): ContactLog[] => {
  if (!logs || logs.length === 0) {
    return [];
  }

  const processed: ContactLog[] = [];
  let attributesGroup: ContactLog[] = [];
  let currentGroupType: string | null = null;
  let getUserInputGroup: ContactLog[] = [];
  let currentGetUserInputIdentifier: string | null = null;
  let invokeExternalGroup: ContactLog[] = [];
  let currentInvokeExternalIdentifier: string | null = null;
  let dialGroup: ContactLog[] = [];
  let currentDialIdentifier: string | null = null;

  const mergeAttributesGroup = () => {
    if (attributesGroup.length === 0) return;

    if (attributesGroup.length === 1) {
      processed.push(attributesGroup[0]);
    } else {
      const baseLog = { ...attributesGroup[0] };
      const isCheckAttribute = baseLog.ContactFlowModuleType === 'CheckAttribute';

      // CheckAttribute의 경우 Parameters에 Results 키를 추가하고 enrichment 데이터 보존
      if (isCheckAttribute) {
        baseLog.Parameters = attributesGroup.map(log => ({
          ...log.Parameters,
          Results: log.Results,
          _comparisonValue: log.Parameters?._comparisonValue,
          _comparisonSecondValue: log.Parameters?._comparisonSecondValue,
        }));
      } else {
        // SetAttributes, SetFlowAttributes의 경우 Parameters만 배열로 저장
        baseLog.Parameters = attributesGroup.map(log => log.Parameters);
      }

      const anyError = attributesGroup.some(
        log =>
          log.Results?.includes('Error') ||
          log.Results?.includes('Failed') ||
          log.ExternalResults?.isSuccess === 'false'
      );

      if (anyError) {
        (baseLog as any)._isGroupError = true;
        baseLog.Results = attributesGroup[attributesGroup.length - 1].Results || "Error in group";
      } else {
        baseLog.Results = attributesGroup[attributesGroup.length - 1].Results;
      }
      baseLog.Timestamp = attributesGroup[attributesGroup.length - 1].Timestamp;
      processed.push(baseLog);
    }
    attributesGroup = [];
    currentGroupType = null;
  };

  const mergeGetUserInputGroup = () => {
    if (getUserInputGroup.length === 0) return;

    if (getUserInputGroup.length === 1) {
      // 단일 로그도 footer 표시를 위해 _footerResults 추가
      const log = { ...getUserInputGroup[0] };
      (log as any)._footerResults = log.Results;
      processed.push(log);
    } else {
      // GetUserInput 로그 병합: 첫 번째 로그의 Parameters를 사용하고, 마지막 로그의 Results를 footer로 표시
      const baseLog = { ...getUserInputGroup[0] };

      // 마지막 로그의 Results 사용 (사용자 입력 결과)
      const finalResults = getUserInputGroup[getUserInputGroup.length - 1].Results;
      baseLog.Results = finalResults;
      baseLog.Timestamp = getUserInputGroup[getUserInputGroup.length - 1].Timestamp;

      // Footer에 표시할 Results를 별도 필드로 저장
      (baseLog as any)._footerResults = finalResults;

      processed.push(baseLog);
    }
    getUserInputGroup = [];
    currentGetUserInputIdentifier = null;
  };

  const mergeInvokeExternalGroup = () => {
    if (invokeExternalGroup.length === 0) return;

    if (invokeExternalGroup.length === 1) {
      // 단일 로그도 footer 표시를 위해 _footerExternalResults 추가
      const log = { ...invokeExternalGroup[0] };
      (log as any)._footerExternalResults = log.ExternalResults;
      processed.push(log);
    } else {
      // InvokeExternalResource 로그 병합: 첫 번째 로그의 Parameters를 사용하고, 마지막 로그의 ExternalResults를 footer로 표시
      const baseLog = { ...invokeExternalGroup[0] };

      // 마지막 로그의 ExternalResults 사용
      const finalExternalResults = invokeExternalGroup[invokeExternalGroup.length - 1].ExternalResults;
      baseLog.ExternalResults = finalExternalResults;
      baseLog.Timestamp = invokeExternalGroup[invokeExternalGroup.length - 1].Timestamp;

      // Footer에 표시할 ExternalResults를 별도 필드로 저장
      (baseLog as any)._footerExternalResults = finalExternalResults;

      processed.push(baseLog);
    }
    invokeExternalGroup = [];
    currentInvokeExternalIdentifier = null;
  };

  const mergeDialGroup = () => {
    if (dialGroup.length === 0) return;

    if (dialGroup.length === 1) {
      processed.push(dialGroup[0]);
    } else {
      // Dial 로그 병합: 첫 번째 로그의 Parameters를 사용하고, 마지막 로그의 Results를 사용
      const baseLog = { ...dialGroup[0] };
      const finalResults = dialGroup[dialGroup.length - 1].Results;

      baseLog.Results = finalResults;
      baseLog.Timestamp = dialGroup[dialGroup.length - 1].Timestamp;

      processed.push(baseLog);
    }
    dialGroup = [];
    currentDialIdentifier = null;
  };

  let i = 0;
  while (i < logs.length) {
    const log = logs[i];
    const isModuleFlow = log.ContactFlowName?.startsWith('MOD_');
    const isInvokeFlowModule = log.ContactFlowModuleType === 'InvokeFlowModule';
    const isReturnFromFlowModule = log.ContactFlowModuleType === 'ReturnFromFlowModule';

    // InvokeFlowModule을 만나면, 다음 MOD_ 로그들을 찾아서 그룹화
    if (isInvokeFlowModule) {
      mergeAttributesGroup();
      mergeGetUserInputGroup();
      mergeInvokeExternalGroup();
      mergeDialGroup();

      // InvokeFlowModule 다음에 오는 MOD_ 로그들 찾기
      let j = i + 1;
      const moduleGroup: ContactLog[] = [];
      let moduleName = 'Unknown Module';

      // 다음 로그가 MOD_로 시작하는지 확인
      if (j < logs.length && logs[j].ContactFlowName?.startsWith('MOD_')) {
        moduleName = logs[j].ContactFlowName || 'Unknown Module';

        // 같은 모듈명을 가진 연속된 로그들 수집
        while (j < logs.length && logs[j].ContactFlowName === moduleName) {
          moduleGroup.push(logs[j]);
          j++;
        }

        // ReturnFromFlowModule 건너뛰기
        if (j < logs.length && logs[j].ContactFlowModuleType === 'ReturnFromFlowModule') {
          j++;
        }

        // 모듈 노드 생성
        const moduleLog = { ...moduleGroup[0] };
        const hasError = moduleGroup.some(
          l =>
            l.Results?.includes('Error') ||
            l.Results?.includes('Failed') ||
            l.ExternalResults?.isSuccess === 'false'
        );
        const timestamps = moduleGroup.map(l => new Date(l.Timestamp).getTime());
        const minTimestamp = new Date(Math.min(...timestamps));
        const maxTimestamp = new Date(Math.max(...timestamps));

        (moduleLog as any)._isModuleNode = true;
        (moduleLog as any)._moduleLogs = moduleGroup;
        (moduleLog as any)._moduleName = moduleName;
        (moduleLog as any)._hasError = hasError;
        (moduleLog as any)._logCount = moduleGroup.length;
        (moduleLog as any)._timeRange = {
          start: minTimestamp.toISOString(),
          end: maxTimestamp.toISOString(),
        };

        processed.push(moduleLog);
        i = j;
      } else {
        // MOD_ 로그가 없으면 InvokeFlowModule만 추가
        processed.push(log);
        i++;
      }
    } else if (isModuleFlow || isReturnFromFlowModule) {
      // MOD_ 로그나 ReturnFromFlowModule은 이미 InvokeFlowModule에서 처리됨
      // 혹시 단독으로 있다면 건너뛰기
      i++;
    } else if (['GetUserInput', 'PlayPrompt', 'StoreUserInput'].includes(log.ContactFlowModuleType)) {
      // GetUserInput 로그 처리: 같은 Identifier를 가진 연속된 로그를 병합
      const identifier = log.Identifier;

      // Identifier가 다르면 이전 그룹을 먼저 병합
      if (currentGetUserInputIdentifier !== null && currentGetUserInputIdentifier !== identifier) {
        mergeGetUserInputGroup();
      }

      // 이전에 다른 그룹이 있었다면 먼저 병합
      mergeAttributesGroup();
      mergeInvokeExternalGroup();
      mergeDialGroup();

      currentGetUserInputIdentifier = identifier || null;
      getUserInputGroup.push(log);
      i++;
    } else if (['InvokeExternalResource', 'InvokeLambdaFunction'].includes(log.ContactFlowModuleType)) {
      // InvokeExternalResource 로그 처리: 같은 Identifier를 가진 연속된 로그를 병합
      const identifier = log.Identifier;

      // Identifier가 다르면 이전 그룹을 먼저 병합
      if (currentInvokeExternalIdentifier !== null && currentInvokeExternalIdentifier !== identifier) {
        mergeInvokeExternalGroup();
      }

      // 이전에 다른 그룹이 있었다면 먼저 병합
      mergeAttributesGroup();
      mergeGetUserInputGroup();
      mergeDialGroup();

      currentInvokeExternalIdentifier = identifier || null;
      invokeExternalGroup.push(log);
      i++;
    } else if (log.ContactFlowModuleType === 'Dial') {
      // Dial 로그 처리: 같은 Identifier를 가진 연속된 로그를 병합
      const identifier = log.Identifier;

      // Identifier가 다르면 이전 그룹을 먼저 병합
      if (currentDialIdentifier !== null && currentDialIdentifier !== identifier) {
        mergeDialGroup();
      }

      // 이전에 다른 그룹이 있었다면 먼저 병합
      mergeAttributesGroup();
      mergeGetUserInputGroup();
      mergeInvokeExternalGroup();

      currentDialIdentifier = identifier || null;
      dialGroup.push(log);
      i++;
    } else if (['SetAttributes', 'SetFlowAttributes', 'CheckAttribute'].includes(log.ContactFlowModuleType)) {
      // 같은 타입의 연속된 로그만 그룹화
      const logType = log.ContactFlowModuleType;

      // 다른 그룹이 있었다면 먼저 병합
      mergeGetUserInputGroup();
      mergeInvokeExternalGroup();
      mergeDialGroup();

      // 타입이 다르면 이전 그룹을 먼저 병합
      if (currentGroupType !== null && currentGroupType !== logType) {
        mergeAttributesGroup();
      }

      currentGroupType = logType;
      attributesGroup.push(log);
      i++;
    } else {
      mergeAttributesGroup();
      mergeGetUserInputGroup();
      mergeInvokeExternalGroup();
      mergeDialGroup();
      processed.push(log);
      i++;
    }
  }

  mergeAttributesGroup();
  mergeGetUserInputGroup();
  mergeInvokeExternalGroup();
  mergeDialGroup();

  return processed;
};

---------------------
/Users/ke-aicc/Downloads/files/src/utils/flowIconMapping.tsx
---------------------
import React from 'react';
import {
  Settings as SettingsIcon,
  Call as CallIcon,
  CallEnd as CallEndIcon,
  PlayArrow as PlayArrowIcon,
  Input as InputIcon,
  Loop as LoopIcon,
  AltRoute as AltRouteIcon,
  AccountTree as AccountTreeIcon,
  Person as PersonIcon,
  Timer as TimerIcon,
  Code as CodeIcon,
  Help as HelpIcon,
  Message as MessageIcon,
  RecordVoiceOver as RecordVoiceOverIcon,
  Pause as PauseIcon,
  FastForward as FastForwardIcon,
  Reply as ReplyIcon,
  Tag as TagIcon,
  Queue as QueueIcon,
  Schedule as ScheduleIcon,
  People as PeopleIcon,
  BarChart as BarChartIcon,
  Security as SecurityIcon,
  SpeakerPhone as SpeakerPhoneIcon,
  Visibility as VisibilityIcon,
  CloudUpload as CloudUploadIcon,
  CloudDownload as CloudDownloadIcon,
  Save as SaveIcon,
  PhoneCallback as PhoneCallbackIcon,
  HourglassEmpty as HourglassEmptyIcon,
  BugReport as BugReportIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Assignment as AssignmentIcon,
  Group as GroupIcon,
  ConnectWithoutContact as ConnectWithoutContactIcon,
  VerifiedUser as VerifiedUserIcon,
  ChangeCircle as ChangeCircleIcon,
  FactCheck as FactCheckIcon,
  AccessTime as AccessTimeIcon,
  Work as WorkIcon,
  Task as TaskIcon,
  Dialpad as DialpadIcon,
  Percent as PercentIcon,
  Forum as ForumIcon,
  Mic as MicIcon,
  VolumeUp as VolumeUpIcon,
  Stop as StopIcon,
  ContactMail as ContactMailIcon,
  Event as EventIcon,
  VoiceChat as VoiceChatIcon,
  SupportAgent as SupportAgentIcon,
  QuestionAnswer as QuestionAnswerIcon,
  Speaker as SpeakerIcon,
  Handshake as HandshakeIcon, // For AssociateContactToCustomerProfile
  Lock as LockIcon, // For AuthenticateParticipant
  Folder as FolderIcon, // For Cases
  AddBox as AddBoxIcon, // For CreateCase
  GetApp as GetAppIcon, // For GetCase
  Update as UpdateIcon, // For UpdateCase
  SwapHoriz as SwapHorizIcon, // For ChangeRoutingPriority
  Rule as RuleIcon, // For CheckAttribute, CheckContactAttributes
  AccessTimeFilled as AccessTimeFilledIcon, // For CheckHoursOfOperation
  QueuePlayNext as QueuePlayNextIcon, // For CheckQueueStatus
  Groups as GroupsIcon, // For CheckStaffing
  Contactless as ContactlessIcon, // For CreatePersistentContactAssociation
  AssignmentTurnedIn as AssignmentTurnedInIcon, // For CreateTask
  AccountCircle as AccountCircleIcon, // For CustomerProfiles, CreateCustomerProfile, GetCustomerProfile
  PhoneInTalk as PhoneInTalkIcon, // For Dial
  CallSplit as CallSplitIcon, // For DistributeByPercentage
  RecordVoiceOver as RecordVoiceOverOutlinedIcon, // For GetCustomerInput, GetUserInput, StoreUserInput, StoreCustomerInput
  QueryStats as QueryStatsIcon, // For GetMetricData, GetQueueMetrics
  PauseCircleFilled as PauseCircleFilledIcon, // For HoldCustomerOrAgent
  Extension as ExtensionIcon, // For InvokeFlowModule
  Repeat as RepeatIcon, // For Loop, LoopPrompts
  ReplyAll as ReplyAllIcon, // For ReturnFromFlowModule
  Send as SendIcon, // For SendMessage
  SettingsInputAntenna as SettingsInputAntennaIcon, // For SetAttributes, SetContactData, SetFlowAttributes
  GroupAdd as GroupAddIcon, // For SetCustomerQueueFlow
  CallEnd as CallEndOutlinedIcon, // For SetDisconnectFlow
  EventNote as EventNoteIcon, // For SetEventHook
  VolumeMute as VolumeMuteIcon, // For SetHoldFlow

  PlaylistAdd as PlaylistAddIcon, // For SetQueue
  MicNone as MicNoneIcon, // For SetRecordingAndAnalyticsBehavior, SetRecordingBehavior
  Route as RouteIcon, // For SetRoutingCriteria
  RecordVoiceOver as RecordVoiceOverRoundedIcon, // For SetVoice
  RecordVoiceOver as RecordVoiceOverSharpIcon, // For SetWhisperFlow
  Lightbulb as LightbulbIcon, // For SetWisdomAssistant
  Visibility as VisibilityOutlinedIcon, // For ShowView
  Stream as StreamIcon, // For StartMediaStreaming, StopMediaStreaming
  Label as LabelIcon, // For TagContact
  CallMade as CallMadeIcon, // For Transfer, TransferToFlow, TransferToPhoneNumber, TransferToQueue
  Update as UpdateOutlinedIcon, // For UpdateAgentState
  PhoneCallback as PhoneCallbackOutlinedIcon, // For UpdateContactCallbackNumber
  HourglassTop as HourglassTopIcon, // For Wait
  BugReport as BugReportOutlinedIcon, // For X-Ray Lambda Log Trace (xray)
} from '@mui/icons-material';

interface FlowIconMap {
  [key: string]: React.ElementType;
}

export const flowIconMap: FlowIconMap = {
  "AssociateContactToCustomerProfile": HandshakeIcon,
  "AuthenticateParticipant": LockIcon,
  "Cases": FolderIcon,
  "CreateCase": AddBoxIcon,
  "GetCase": GetAppIcon,
  "UpdateCase": UpdateIcon,
  "ChangeRoutingPriority": SwapHorizIcon,
  "CheckAttribute": FactCheckIcon,
  "CheckContactAttributes": FactCheckIcon,
  "CheckHoursOfOperation": AccessTimeFilledIcon,
  "CheckQueueStatus": QueuePlayNextIcon,
  "CheckStaffing": GroupsIcon,
  "CreatePersistentContactAssociation": ContactlessIcon,
  "CreateTask": AssignmentTurnedInIcon,
  "CustomerProfiles": AccountCircleIcon,
  "CreateCustomerProfile": AccountCircleIcon,
  "Dial": PhoneInTalkIcon,
  "Disconnect": CallEndIcon,
  "DistributeByPercentage": PercentIcon,
  "GetCustomerInput": RecordVoiceOverOutlinedIcon,
  "ConnectParticipantWithLexBot": QuestionAnswerIcon, // Using QuestionAnswer for LexBot
  "GetCustomerProfile": AccountCircleIcon,
  "GetMetricData": BarChartIcon,
  "GetQueueMetrics": BarChartIcon,
  "GetUserInput": RecordVoiceOverOutlinedIcon,
  "HoldCustomerOrAgent": PauseCircleFilledIcon,
  "InvokeExternalResource": CodeIcon, // Lambda function call
  "InvokeFlowModule": ExtensionIcon,
  "InvokeLambdaFunction": CodeIcon, // Lambda function call
  "Loop": LoopIcon,
  "LoopPrompts": LoopIcon, // Same as Loop for now
  "PlayPrompt": PlayArrowIcon,
  "Resume": FastForwardIcon,
  "ResumeContact": FastForwardIcon,
  "ReturnFromFlowModule": ReplyAllIcon,
  "SendMessage": SendIcon,
  "SetAttributes": SettingsInputAntennaIcon,
  "SetContactData": SettingsInputAntennaIcon,
  "SetCustomerQueueFlow": GroupAddIcon,
  "SetDisconnectFlow": CallEndOutlinedIcon,
  "SetEventHook": EventNoteIcon,
  "SetFlowAttributes": SettingsInputAntennaIcon,
  "SetHoldFlow": VolumeMuteIcon,
  "SetLoggingBehavior": SettingsIcon, // Using Settings for logging behavior
  "SetQueue": PlaylistAddIcon,
  "SetRecordingAndAnalyticsBehavior": MicNoneIcon,
  "SetRecordingBehavior": MicNoneIcon,
  "SetRoutingCriteria": RouteIcon,
  "SetVoice": RecordVoiceOverRoundedIcon,
  "SetWhisperFlow": RecordVoiceOverSharpIcon,
  "SetWisdomAssistant": LightbulbIcon,
  "ShowView": VisibilityOutlinedIcon,
  "StartMediaStreaming": StreamIcon,
  "StopMediaStreaming": StopIcon,
  "StoreCustomerInput": SaveIcon,
  "StoreUserInput": SaveIcon,
  "TagContact": LabelIcon,
  "Transfer": CallMadeIcon,
  "TransferToFlow": CallMadeIcon,
  "TransferToPhoneNumber": CallMadeIcon,
  "TransferToQueue": CallMadeIcon,
  "UpdateAgentState": SupportAgentIcon, // Using SupportAgent for agent state update
  "UpdateContactCallbackNumber": PhoneCallbackOutlinedIcon,
  "Wait": HourglassTopIcon,
  "xray": BugReportOutlinedIcon, // Using BugReport for X-Ray
};

export const getFlowIcon = (moduleType: string): React.ElementType => {
  return flowIconMap[moduleType] || HelpIcon; // Default to HelpIcon if not found
};


---------------------
/Users/ke-aicc/Downloads/files/src/components/ErrorBoundary/ErrorBoundary.tsx
---------------------
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Box, Typography, Button } from '@mui/material';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <Box sx={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          minHeight: '100vh',
          p: 3
        }}>
          <Typography variant="h4" gutterBottom color="error">
            Oops! Something went wrong
          </Typography>
          <Typography variant="body1" sx={{ mb: 2 }}>
            {this.state.error?.message}
          </Typography>
          <Button
            variant="contained"
            onClick={() => this.setState({ hasError: false })}
          >
            Try again
          </Button>
        </Box>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


---------------------
/Users/ke-aicc/Downloads/files/src/components/TranscriptPanel/TranscriptPanel.tsx
---------------------
import React from 'react';
import { Drawer, Box, Typography, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';

interface TranscriptPanelProps {
  open: boolean;
  onClose: () => void;
  transcript?: any[];
}

const TranscriptPanel: React.FC<TranscriptPanelProps> = ({ open, onClose, transcript = [] }) => {
  return (
    <Drawer
      anchor="right"
      open={open}
      onClose={onClose}
      sx={{
        '& .MuiDrawer-paper': {
          width: 400,
          p: 2
        }
      }}
    >
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6">Transcript</Typography>
        <IconButton onClick={onClose}>
          <CloseIcon />
        </IconButton>
      </Box>
      <Box>
        {transcript.length === 0 ? (
          <Typography variant="body2" color="text.secondary">
            No transcript available
          </Typography>
        ) : (
          <Box>
            {transcript.map((item, index) => (
              <Box key={index} sx={{ mb: 2, p: 1, bgcolor: 'grey.100', borderRadius: 1 }}>
                <pre style={{ fontSize: '0.875rem', overflow: 'auto', margin: 0 }}>
                  {JSON.stringify(item, null, 2)}
                </pre>
              </Box>
            ))}
          </Box>
        )}
      </Box>
    </Drawer>
  );
};

export default TranscriptPanel;


---------------------
/Users/ke-aicc/Downloads/files/src/components/FlowNodes/CustomNode.tsx
---------------------
import React, { useEffect, useState } from 'react';
import { Handle, Position } from 'react-flow-renderer';
import { Box, Typography, Chip } from '@mui/material';
import { AccountTree as ModuleIcon } from '@mui/icons-material';

import { NodeContentRenderer } from './NodeContentRenderer';
import console from 'console';

interface CustomNodeProps {
  data: {
    label: string;
    moduleType?: string;
    error?: boolean;
    timestamp?: string;
    logCount?: number;
    timeRange?: {
      start: string;
      end: string;
    };
    sourcePosition?: Position;
    targetPosition?: Position;
    isModuleNode?: boolean;
    [key: string]: any; // Allow other properties
  };
  // isMainView?: boolean; // New prop
}

const CustomNode: React.FC<CustomNodeProps> = ({ data }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const isMainView = data.isMainView || false;
  const hasError = data.error || false;
  const isModuleNode = data.isModuleNode || false;
  const bgColor = hasError ? '#FFEBEE' : isModuleNode ? '#E3F2FD' : '#FFFFFF';
  const borderColor = hasError ? '#F44336' : isModuleNode ? '#2196F3' : '#E0E0E0';
  const targetPosition = data.targetPosition || Position.Left;
  const sourcePosition = data.sourcePosition || Position.Right;

  // React Flow 노드의 부모 wrapper에 z-index 적용
  useEffect(() => {
    if (isExpanded) {
      const nodeElement = document.querySelector(`[data-id="${data.id}"]`);
      if (nodeElement) {
        (nodeElement as HTMLElement).style.zIndex = '9999';
      }
    } else {
      const nodeElement = document.querySelector(`[data-id="${data.id}"]`);
      if (nodeElement) {
        (nodeElement as HTMLElement).style.zIndex = '';
      }
    }
  }, [isExpanded, data.id]);




  const renderMainViewContent = () => (
    <>
      {data.timeRange && (
        <Box sx={{ mt: 'auto' }}>
          <Typography variant="caption" color="text.secondary" display="block">
            {new Date(data.timeRange.start).toLocaleString('ko-KR')} ~
          </Typography>
          <Typography variant="caption" color="text.secondary" display="block">
            {new Date(data.timeRange.end).toLocaleString('ko-KR')}
          </Typography>
          {data.logCount && (
            <Typography variant="caption" fontWeight="bold" sx={{ mt: 1 }}>
              Nodes : {data.logCount}
            </Typography>
          )}
          <br />
          {data.timeRange && (
            <Typography variant="caption" fontWeight="bold" sx={{ mt: 1 }}>
              Duration : {((new Date(data.timeRange.end).getTime() - new Date(data.timeRange.start).getTime()) / 1000).toFixed(2)}s
            </Typography>
          )}
        </Box>
      )}
    </>
  );

  const renderDetailViewContent = () => {
    return (
      <>
        {!isModuleNode ? (
          <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
            <Box sx={{ flex: 1, overflowY: 'auto' }}>
              <NodeContentRenderer data={data} />
            </Box>
          </Box>
        ) : (
          <>
            {data.timeRange && (
              <Box>
                <Typography variant="caption" color="text.secondary" display="block">
                  {new Date(data.timeRange.start).toLocaleString('ko-KR')} ~
                </Typography>
                <Typography variant="caption" color="text.secondary" display="block">
                  {new Date(data.timeRange.end).toLocaleString('ko-KR')}
                </Typography>
              </Box>
            )}
            {data.logCount && (
              <Typography variant="body2" fontWeight="bold" sx={{ mt: 1 }}>
                Nodes : {data.logCount}
              </Typography>
            )}
            <Chip
              label="Click to view details"
              size="small"
              icon={<ModuleIcon sx={{ fontSize: '1rem' }} />}
              sx={{ mt: 1, cursor: 'pointer' }}
            />
          </>
        )}
      </>
    );
  };

  const hasFooterResults = data.logData?._footerResults && ['PlayPrompt', 'StoreUserInput', 'GetUserInput'].includes(data?.moduleType ?? '');
  const footerResults = data.logData?._footerResults;

  const hasFooterExternalResults = data.logData?._footerExternalResults && ['InvokeExternalResource', 'InvokeLambdaFunction'].includes(data?.moduleType ?? '');
  const footerExternalResults = data.logData?._footerExternalResults;

  return (
    <Box
      className="nopan" // React Flow class to disable panning on drag
      onWheel={(e) => e.stopPropagation()} // Stop zoom/pan on scroll
      onMouseEnter={() => setIsExpanded(true)}
      onMouseLeave={() => setIsExpanded(false)}
      sx={{
        padding: 1,
        borderRadius: 2,
        border: `2px solid ${borderColor}`,
        backgroundColor: bgColor,
        width: 280,
        height: isExpanded ? 'auto' : 180,
        minHeight: 180,
        maxHeight: isExpanded ? 'none' : 180,
        boxShadow: isExpanded ? '0 8px 16px rgba(0,0,0,0.2)' : '0 2px 4px rgba(0,0,0,0.1)',
        display: 'flex',
        flexDirection: 'column',
        position: isExpanded ? 'absolute' : 'relative',
        zIndex: isExpanded ? '9999 !important' : 'auto',
        transition: 'all 0.2s ease-in-out',
        transform: isExpanded ? 'scale(1.02)' : 'scale(1)',
        isolation: isExpanded ? 'isolate' : 'auto',
        willChange: isExpanded ? 'transform, z-index' : 'auto',
        '&:hover': {
          boxShadow: '0 8px 16px rgba(0,0,0,0.2)',
        },
      }}
    >
      {/* Target Handles */}
      <Handle type="target" position={Position.Top} id="target-top" style={{ background: '#555' }} />
      <Handle type="target" position={Position.Bottom} id="target-bottom" style={{ background: '#555' }} />
      <Handle type="target" position={Position.Left} id="target-left" style={{ background: '#555' }} />
      <Handle type="target" position={Position.Right} id="target-right" style={{ background: '#555' }} />

      {/* Header */}
      <Box sx={{ borderBottom: `1px solid ${borderColor}` }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, p: 1, pb: 0.5 }}>
          <img
            src={isMainView ? `/icons/img/InvokeFlowModule.png` : `/icons/img/${data.moduleType}.png`}
            alt={`${data.moduleType} icon`}
            width="20"
            height="20"
            onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}
            style={{ objectFit: 'contain' }}
          />
          <Typography variant="subtitle2" fontWeight="600" sx={{ color: hasError ? '#D32F2F' : '#1976D2' }} noWrap>
            {data.label}
          </Typography>
        </Box>
        {data.logData?.Identifier && (
          <Box sx={{ px: 1, pb: 0.5 }}>
            <Typography variant="caption" sx={{ color: '#6B7280', fontSize: '0.65rem' }} noWrap>
              {data.logData.Identifier}
            </Typography>
          </Box>
        )}
      </Box>

      {/* Body */}
      <Box
        className="nodrag" // Prevents react-flow drag events on this element
        sx={{
          flex: 1,
          overflowY: isExpanded ? 'visible' : 'auto',
          overflowX: 'hidden',
          p: 1,
          minHeight: 0,
          overscrollBehavior: 'contain' // Prevents scroll chaining to parent (canvas)
        }}
      >
        {isMainView ? renderMainViewContent() : renderDetailViewContent()}
      </Box>

      {/* Footer - GetUserInput Results */}
      {!isMainView && hasFooterResults && (
        <Box sx={{
          borderTop: `1px solid ${borderColor}`,
          p: 1,
          backgroundColor: footerResults?.includes('Error') || footerResults?.includes('Timeout') ? '#FFEBEE' : '#E8F5E9',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          minHeight: '32px'
        }}>
          <Typography variant="caption" fontWeight="bold" sx={{
            color: footerResults?.includes('Error') || footerResults?.includes('Timeout') ? '#D32F2F' : '#2E7D32'
          }}>
            Results: {footerResults}
          </Typography>
        </Box>
      )}

      {/* Footer - InvokeExternalResource Results */}
      {!isMainView && hasFooterExternalResults && (
        <Box sx={{
          borderTop: `1px solid ${borderColor}`,
          px: 1.5,
          py: 0.75,
          backgroundColor: footerExternalResults?.isSuccess === 'false' ? '#FFF3F3' : '#F0F9F4',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          minHeight: '28px'
        }}>
          <Typography variant="caption" sx={{ color: '#666', fontWeight: 500 }}>
            Status
          </Typography>
          <Box sx={{
            display: 'inline-flex',
            alignItems: 'center',
            gap: 0.5,
            px: 1,
            py: 0.25,
            borderRadius: '4px',
            backgroundColor: footerExternalResults?.isSuccess === 'false' ? '#FEE' : '#E8F5E9',
            border: `1px solid ${footerExternalResults?.isSuccess === 'false' ? '#FFCDD2' : '#C8E6C9'}`
          }}>
            <Box sx={{
              width: 6,
              height: 6,
              borderRadius: '50%',
              backgroundColor: footerExternalResults?.isSuccess === 'false' ? '#F44336' : '#4CAF50'
            }} />
            <Typography variant="caption" sx={{
              color: footerExternalResults?.isSuccess === 'false' ? '#D32F2F' : '#2E7D32',
              fontWeight: 600,
              fontSize: '0.7rem'
            }}>
              {footerExternalResults?.isSuccess === 'true' ? 'Success' : 'Failed'}
            </Typography>
          </Box>
        </Box>
      )}

      {/* Source Handles */}
      <Handle type="source" position={Position.Top} id="source-top" style={{ background: '#555' }} />
      <Handle type="source" position={Position.Bottom} id="source-bottom" style={{ background: '#555' }} />
      <Handle type="source" position={Position.Left} id="source-left" style={{ background: '#555' }} />
      <Handle type="source" position={Position.Right} id="source-right" style={{ background: '#555' }} />
    </Box>
  );
};

export default CustomNode;



---------------------
/Users/ke-aicc/Downloads/files/src/components/FlowNodes/NodeContentRenderer.tsx
---------------------
import React from 'react';
import { Box, Typography, Chip } from '@mui/material';

const renderValue = (value: any, max_length: number = 30) => {
  let strValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
  if (strValue.length > max_length) {
    strValue = strValue.substring(0, max_length) + '...';
  }
  return strValue;
};

const getOperatorSymbol = (op: string) => {
  const symbols: Record<string, string> = {
    'Contains': '⊃',
    'Equals': '=',
    'GreaterThan': '>',
    'GreaterThanOrEqualTo': '≥',
    'LessThan': '<',
    'LessThanOrEqualTo': '≤',
    'StartsWith': 'SW',
  };
  return symbols[op] || op;
};

export const NodeContentRenderer = ({ data }: { data: any }) => {
  const { moduleType, parameters, results } = data;
  const params = parameters || {};

  const renderContent = () => {
    switch (moduleType) {
      case 'CheckAttribute': {
        const checks = Array.isArray(params) ? params : [params];
        return (
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
            {checks.map((p, i) => {
              const operator = getOperatorSymbol(p.ComparisonMethod);
              const result = p.Results || (i === checks.length - 1 ? results : '');

              // Flow definition에서 가져온 비교값 추가
              const comparisonValue = p._comparisonValue;
              const comparisonSecondValue = p._comparisonSecondValue;

              // 값 표시 형식: value($.Attributes.AttributeName)
              const displayValue = p.Value + (comparisonValue ? `(${comparisonValue})` : '');
              const displaySecondValue = p.SecondValue + (comparisonSecondValue ? `(${comparisonSecondValue})` : '');

              return (
                <Box key={i} sx={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 0.5,
                  p: 0.5,
                  borderRadius: 0.75,
                  backgroundColor: '#F9FAFB',
                  border: '1px solid #E5E7EB'
                }}>
                  <Typography variant="caption" sx={{
                    flex: 1,
                    color: '#374151',
                    lineHeight: 1.3,
                    fontSize: '0.7rem',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }}>
                    {renderValue(displayValue, 20)} <Box component="span" sx={{ color: '#6B7280', fontWeight: 600 }}>{operator}</Box> {renderValue(displaySecondValue, 15)}?
                  </Typography>
                  <Box sx={{
                    display: 'inline-flex',
                    alignItems: 'center',
                    gap: 0.4,
                    px: 0.6,
                    py: 0.2,
                    borderRadius: '10px',
                    fontSize: '0.6rem',
                    fontWeight: 600,
                    whiteSpace: 'nowrap',
                    flexShrink: 0,
                    ...(result === 'true' ? {
                      backgroundColor: '#ECFDF5',
                      color: '#047857',
                      border: '1px solid #A7F3D0'
                    } : result === 'false' ? {
                      backgroundColor: '#FEF2F2',
                      color: '#DC2626',
                      border: '1px solid #FECACA'
                    } : {
                      backgroundColor: '#F3F4F6',
                      color: '#6B7280',
                      border: '1px solid #E5E7EB'
                    })
                  }}>
                    <Box sx={{
                      width: 4,
                      height: 4,
                      borderRadius: '50%',
                      backgroundColor: result === 'true' ? '#10B981' : result === 'false' ? '#EF4444' : '#9CA3AF'
                    }} />
                    {result || 'N/A'}
                  </Box>
                </Box>
              );
            })}
          </Box>
        );
      }
      case 'InvokeExternalResource':
      case 'InvokeLambdaFunction': {
        const funcParams = params.Parameters || {};
        return (
          <Box>
            {Object.entries(funcParams).map(([key, value]) => (
              <Typography variant="caption" display="block" key={key}>
                {key}: {renderValue(value)}
              </Typography>
            ))}
            {/* Results는 이제 Footer에 표시되므로 여기서는 제거 */}
          </Box>
        );
      }
      case 'PlayPrompt':
      case 'StoreUserInput':
      case 'GetUserInput': {
        // GetUserInput의 경우 Parameters의 주요 정보 표시
        return (
          <Box>
            {/* Text-to-Speech 또는 S3 Prompt 표시 */}
            {params.Text && (
              <Typography variant="body2" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all', mb: 1 }}>
                {renderValue(params.Text, 100)}
              </Typography>
            )}
            {params.PromptLocation && (
              <Typography variant="caption" display="block" sx={{ mb: 1 }}>
                📢 Prompt: {renderValue(params.PromptLocation, 50)}
              </Typography>
            )}
            {/* 추가 파라미터 표시 */}
            {params.TextToSpeechType && (
              <Typography variant="caption" display="block">
                TTS Type: {params.TextToSpeechType}
              </Typography>
            )}
            {params.Voice && (
              <Typography variant="caption" display="block">
                Voice: {params.Voice}
              </Typography>
            )}
            {params.PromptSource && (
              <Typography variant="caption" display="block">
                Source: {params.PromptSource}
              </Typography>
            )}
            {params.MaxDigits && (
              <Typography variant="caption" display="block">
                Max Digits: {params.MaxDigits}
              </Typography>
            )}
            {params.Timeout && (
              <Typography variant="caption" display="block">
                Timeout: {params.Timeout}ms
              </Typography>
            )}
          </Box>
        );
      }

      case 'SetAttributes':
      case 'SetFlowAttributes': {
        const attrs = Array.isArray(params) ? params : [params];
        return (
          <Box>
            {attrs.map((p, i) => (
              <Typography variant="caption" display="block" key={i}>
                {p.Key} = {renderValue(p.Value, 15)}
              </Typography>
            ))}
          </Box>
        );
      }
      case 'SetLoggingBehavior':
        return <Typography variant="body2">Logging: {params.LoggingBehavior}</Typography>;
      case 'TagContact':
        return (
          <Box>
            {Object.entries(params.Tags).map(([key, value]) => (
              <Typography variant="caption" display="block" key={key}>
                {key}: {renderValue(value)}
              </Typography>
            ))}
          </Box>
        )
      case 'SetContactFlow':
      case 'SetContactData':
        return (
          <Box>
            {Object.entries(params).map(([key, value]) => (
              <Typography variant="caption" display="block" key={key}>
                {key}: {renderValue(value)}
              </Typography>
            ))}
          </Box>
        );
      case 'GetCustomerProfile':
        return (
          <Typography variant="body2" sx={{ wordBreak: 'break-all' }}>
            ProfileId: {data.logData?.ResultData?.ProfileId}
            <br />
            <small>Result: {results}</small>
          </Typography>
        );
      default:
        return (
          <Box>
            {Object.entries(params).map(([key, value]) => (
              <Typography variant="caption" display="block" key={key}>
                {key}: {renderValue(value)}
              </Typography>
            ))}
            {results && <small>Result: {results}</small>}
          </Box>
        );
    }
  };

  return (
    <Box sx={{ p: 1, height: '100%' }}>
      {renderContent()}
    </Box>
  );
};


---------------------
/Users/ke-aicc/Downloads/files/src/components/FlowNodes/XRayNode.tsx
---------------------
import React, { useState } from 'react';
import { Handle, Position } from 'react-flow-renderer';
import { Box, Typography, Chip } from '@mui/material';
import {
  CloudCircle as CloudIcon,
  Storage as StorageIcon,
  Functions as LambdaIcon,
  Info as InfoIcon,
  Warning as WarningIcon,
  Error as ErrorIcon,
} from '@mui/icons-material';

interface XRayNodeProps {
  data: {
    label: string;
    segmentData?: any;
    logData?: any;
    error?: boolean;
    duration?: number;
    service?: string;
    operation?: string;
    resource?: string;
    httpMethod?: string;
    httpUrl?: string;
    httpStatus?: number;
    message?: string;
    timestamp?: string;
  };
}

const XRayNode: React.FC<XRayNodeProps> = ({ data }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const isError = data.error || false;
  const isLambdaLog = !!data.logData;
  const isSegment = !!data.segmentData;

  // Determine colors
  const bgColor = isError ? '#FFEBEE' : isLambdaLog ? '#E3F2FD' : '#E8F5E9';
  const borderColor = isError ? '#F44336' : isLambdaLog ? '#2196F3' : '#4CAF50';

  // Get icon based on service type
  const getServiceIcon = () => {
    if (isLambdaLog) {
      if (data.label === 'ERROR') return <ErrorIcon sx={{ fontSize: '1rem', color: '#D32F2F' }} />;
      if (data.label === 'WARN') return <WarningIcon sx={{ fontSize: '1rem', color: '#F57C00' }} />;
      return <InfoIcon sx={{ fontSize: '1rem', color: '#1976D2' }} />;
    }

    const service = data.service?.toLowerCase() || '';
    if (service.includes('lambda')) return <LambdaIcon sx={{ fontSize: '1rem' }} />;
    if (service.includes('dynamodb') || service.includes('s3')) return <StorageIcon sx={{ fontSize: '1rem' }} />;
    return <CloudIcon sx={{ fontSize: '1rem' }} />;
  };

  // Format duration
  const formatDuration = (duration?: number) => {
    if (!duration) return '';
    if (duration < 1) return `${(duration * 1000).toFixed(2)}ms`;
    return `${duration.toFixed(2)}s`;
  };

  // Render segment content
  const renderSegmentContent = () => {
    if (!isSegment) return null;

    return (
      <Box sx={{ p: 1 }}>
        {data.operation && (
          <Typography variant="caption" display="block" sx={{ color: '#666' }}>
            <strong>Operation:</strong> {data.operation}
          </Typography>
        )}
        {data.resource && (
          <Typography variant="caption" display="block" sx={{ color: '#666' }}>
            <strong>Resource:</strong> {data.resource.split('/').pop()}
          </Typography>
        )}
        {data.httpMethod && data.httpUrl && (
          <Typography variant="caption" display="block" sx={{ color: '#666' }}>
            <strong>HTTP:</strong> {data.httpMethod} {data.httpUrl.split('/').slice(3).join('/')}
          </Typography>
        )}
        {data.httpStatus && (
          <Chip
            label={`Status: ${data.httpStatus}`}
            size="small"
            color={data.httpStatus >= 200 && data.httpStatus < 300 ? 'success' : 'error'}
            sx={{ mt: 0.5 }}
          />
        )}
        {data.duration !== undefined && (
          <Typography variant="caption" display="block" sx={{ color: '#666', mt: 0.5 }}>
            <strong>Duration:</strong> {formatDuration(data.duration)}
          </Typography>
        )}
      </Box>
    );
  };

  // Render Lambda log content
  const renderLogContent = () => {
    if (!isLambdaLog) return null;

    return (
      <Box sx={{ p: 1 }}>
        {data.message && (
          <Typography
            variant="caption"
            display="block"
            sx={{
              color: '#333',
              whiteSpace: isExpanded ? 'pre-wrap' : 'nowrap',
              overflow: isExpanded ? 'visible' : 'hidden',
              textOverflow: isExpanded ? 'clip' : 'ellipsis',
              wordBreak: 'break-word',
            }}
          >
            {data.message}
          </Typography>
        )}
        {data.timestamp && (
          <Typography variant="caption" display="block" sx={{ color: '#999', mt: 0.5 }}>
            {new Date(data.timestamp).toLocaleString('ko-KR')}
          </Typography>
        )}
      </Box>
    );
  };

  return (
    <Box
      className="nopan"
      onMouseEnter={() => setIsExpanded(true)}
      onMouseLeave={() => setIsExpanded(false)}
      sx={{
        padding: 1,
        borderRadius: 2,
        border: `2px solid ${borderColor}`,
        backgroundColor: bgColor,
        width: 280,
        height: isExpanded ? 'auto' : 160,
        minHeight: 160,
        maxHeight: isExpanded ? 'none' : 160,
        boxShadow: isExpanded ? '0 8px 16px rgba(0,0,0,0.2)' : '0 2px 4px rgba(0,0,0,0.1)',
        display: 'flex',
        flexDirection: 'column',
        position: isExpanded ? 'absolute' : 'relative',
        zIndex: isExpanded ? '9999 !important' : 'auto',
        transition: 'all 0.2s ease-in-out',
        transform: isExpanded ? 'scale(1.02)' : 'scale(1)',
        isolation: isExpanded ? 'isolate' : 'auto',
        willChange: isExpanded ? 'transform, z-index' : 'auto',
        '&:hover': {
          boxShadow: '0 8px 16px rgba(0,0,0,0.2)',
        },
      }}
    >
      {/* Target Handles */}
      <Handle type="target" position={Position.Top} id="target-top" style={{ background: '#555' }} />
      <Handle type="target" position={Position.Bottom} id="target-bottom" style={{ background: '#555' }} />
      <Handle type="target" position={Position.Left} id="target-left" style={{ background: '#555' }} />
      <Handle type="target" position={Position.Right} id="target-right" style={{ background: '#555' }} />

      {/* Header */}
      <Box
        sx={{
          borderBottom: `1px solid ${borderColor}`,
          display: 'flex',
          alignItems: 'center',
          gap: 1,
          p: 1,
          pb: 0.5,
        }}
      >
        {getServiceIcon()}
        <Typography variant="subtitle2" fontWeight="600" sx={{ color: isError ? '#D32F2F' : '#1976D2' }}>
          {data.label}
        </Typography>
        {data.service && (
          <Chip label={data.service} size="small" sx={{ ml: 'auto', fontSize: '0.65rem', height: '18px' }} />
        )}
      </Box>

      {/* Body */}
      <Box
        className="nodrag"
        sx={{
          flex: 1,
          overflowY: isExpanded ? 'visible' : 'auto',
          overflowX: 'hidden',
          minHeight: 0,
        }}
      >
        {isSegment ? renderSegmentContent() : renderLogContent()}
      </Box>

      {/* Source Handles */}
      <Handle type="source" position={Position.Top} id="source-top" style={{ background: '#555' }} />
      <Handle type="source" position={Position.Bottom} id="source-bottom" style={{ background: '#555' }} />
      <Handle type="source" position={Position.Left} id="source-left" style={{ background: '#555' }} />
      <Handle type="source" position={Position.Right} id="source-right" style={{ background: '#555' }} />
    </Box>
  );
};

export default XRayNode;


---------------------
/Users/ke-aicc/Downloads/files/src/components/Layout/Layout.tsx
---------------------
import React, { useState } from 'react';
import {
  AppBar,
  Box,
  CssBaseline,
  Drawer,
  IconButton,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Typography,
  Divider,
  Avatar,
  Menu,
  MenuItem,
  Badge,
  Tooltip,
  useTheme,
} from '@mui/material';
import {
  Menu as MenuIcon,
  Dashboard as DashboardIcon,
  Timeline as TimelineIcon,
  CloudQueue as CloudIcon,
  Settings as SettingsIcon,
  Logout as LogoutIcon,
  Person as PersonIcon,
  Notifications as NotificationsIcon,
  AccountTree as FlowIcon,
  Description as LogsIcon,
  Help as HelpIcon,
  ChevronLeft as ChevronLeftIcon,
  ChevronRight as ChevronRightIcon,
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';

const drawerWidth = 240;
const collapsedDrawerWidth = 60;

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const theme = useTheme();
  const { user, logout } = useAuth();
  const [mobileOpen, setMobileOpen] = useState(false);
  const [isNavCollapsed, setIsNavCollapsed] = useState(false);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [notificationAnchor, setNotificationAnchor] = useState<null | HTMLElement>(null);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleProfileMenuClose = () => {
    setAnchorEl(null);
  };

  const handleNotificationOpen = (event: React.MouseEvent<HTMLElement>) => {
    setNotificationAnchor(event.currentTarget);
  };

  const handleNotificationClose = () => {
    setNotificationAnchor(null);
  };

  const handleLogout = () => {
    logout();
    navigate('/');
  };

  const menuItems = [
    { text: 'Dashboard', icon: <DashboardIcon />, path: '/' },
    { text: 'Contact Flow', icon: <FlowIcon />, path: '/contact-flow' },
    { text: 'Log Analysis', icon: <LogsIcon />, path: '/logs' },
    { text: 'Settings', icon: <SettingsIcon />, path: '/settings' },
  ];

  const drawer = (
    <div>
      <Toolbar sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        {!isNavCollapsed && (
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <CloudIcon sx={{ mr: 1, color: 'primary.main' }} />
            <Typography variant="h6" noWrap component="div">
              AWS Tracer
            </Typography>
          </Box>
        )}
        <IconButton onClick={() => setIsNavCollapsed(!isNavCollapsed)} sx={{ display: { xs: 'none', sm: 'block' } }}>
          {isNavCollapsed ? <ChevronRightIcon /> : <ChevronLeftIcon />}
        </IconButton>
      </Toolbar>
      <Divider />
      <List>
        {menuItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <Tooltip title={isNavCollapsed ? item.text : ''} placement="right">
              <ListItemButton
                selected={location.pathname === item.path}
                onClick={() => navigate(item.path)}
                sx={{ justifyContent: isNavCollapsed ? 'center' : 'initial' }}
              >
                <ListItemIcon sx={{ minWidth: 0, mr: isNavCollapsed ? 0 : 3, justifyContent: 'center' }}>
                  {item.icon}
                </ListItemIcon>
                <ListItemText primary={item.text} sx={{ opacity: isNavCollapsed ? 0 : 1 }} />
              </ListItemButton>
            </Tooltip>
          </ListItem>
        ))}
      </List>
      <Divider />
      <List>
        <ListItem disablePadding>
          <Tooltip title={isNavCollapsed ? "Help & Docs" : ''} placement="right">
            <ListItemButton
              onClick={() => window.open('https://docs.aws.amazon.com/connect/', '_blank')}
              sx={{ justifyContent: isNavCollapsed ? 'center' : 'initial' }}
            >
              <ListItemIcon sx={{ minWidth: 0, mr: isNavCollapsed ? 0 : 3, justifyContent: 'center' }}>
                <HelpIcon />
              </ListItemIcon>
              <ListItemText primary="Help & Docs" sx={{ opacity: isNavCollapsed ? 0 : 1 }} />
            </ListItemButton>
          </Tooltip>
        </ListItem>
      </List>
    </div>
  );

  const currentDrawerWidth = isNavCollapsed ? collapsedDrawerWidth : drawerWidth;

  return (
    <Box sx={{ display: 'flex' }}>
      <CssBaseline />
      <AppBar
        position="fixed"
        sx={{
          width: { sm: `calc(100% - ${currentDrawerWidth}px)` },
          ml: { sm: `${currentDrawerWidth}px` },
          transition: theme.transitions.create(['width', 'margin'], {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { sm: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            Contact Tracer
          </Typography>
          
          <Tooltip title="Notifications">
            <IconButton color="inherit" onClick={handleNotificationOpen}>
              <Badge badgeContent={3} color="error">
                <NotificationsIcon />
              </Badge>
            </IconButton>
          </Tooltip>
          
          <Tooltip title="Account">
            <IconButton
              onClick={handleProfileMenuOpen}
              size="small"
              sx={{ ml: 2 }}
            >
              <Avatar sx={{ width: 32, height: 32, bgcolor: 'secondary.main' }}>
                {user?.name?.charAt(0) || 'U'}
              </Avatar>
            </IconButton>
          </Tooltip>
        </Toolbar>
      </AppBar>
      
      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleProfileMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <MenuItem onClick={() => { handleProfileMenuClose(); navigate('/settings'); }}>
          <ListItemIcon>
            <PersonIcon fontSize="small" />
          </ListItemIcon>
          Profile
        </MenuItem>
        <MenuItem onClick={() => { handleProfileMenuClose(); navigate('/settings'); }}>
          <ListItemIcon>
            <SettingsIcon fontSize="small" />
          </ListItemIcon>
          Settings
        </MenuItem>
        <Divider />
        <MenuItem onClick={handleLogout}>
          <ListItemIcon>
            <LogoutIcon fontSize="small" />
          </ListItemIcon>
          Logout
        </MenuItem>
      </Menu>
      
      <Menu
        anchorEl={notificationAnchor}
        open={Boolean(notificationAnchor)}
        onClose={handleNotificationClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <MenuItem onClick={handleNotificationClose}>
          <Typography variant="body2">New contact flow error detected</Typography>
        </MenuItem>
        <MenuItem onClick={handleNotificationClose}>
          <Typography variant="body2">Lambda function timeout</Typography>
        </MenuItem>
        <MenuItem onClick={handleNotificationClose}>
          <Typography variant="body2">High abandon rate alert</Typography>
        </MenuItem>
      </Menu>
      
      <Box
        component="nav"
        sx={{ width: { sm: currentDrawerWidth }, flexShrink: { sm: 0 } }}
      >
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true,
          }}
          sx={{
            display: { xs: 'block', sm: 'none' },
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: drawerWidth,
            },
          }}
        >
          {drawer}
        </Drawer>
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', sm: 'block' },
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: currentDrawerWidth,
              transition: theme.transitions.create('width', {
                easing: theme.transitions.easing.sharp,
                duration: theme.transitions.duration.enteringScreen,
              }),
              overflowX: 'hidden',
            },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>
      
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { sm: `calc(100% - ${currentDrawerWidth}px)` },
          transition: theme.transitions.create(['width', 'margin'], {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
        }}
      >
        <Toolbar />
        {children}
      </Box>
    </Box>
  );
};

export default Layout;


---------------------
/Users/ke-aicc/Downloads/files/src/components/LogDetailsDrawer/LogDetailsDrawer.tsx
---------------------
import React from 'react';
import {
  Drawer,
  Box,
  Typography,
  IconButton,
  Divider,
  Chip,
  Stack,
  Paper,
  Button,
  CircularProgress,
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import { ContactLog } from '@/types/contact.types';

interface LogDetailsDrawerProps {
  open: boolean;
  onClose: () => void;
  log?: ContactLog | null;
  subFlowLogs?: ContactLog[];
  isFetchingSubFlow?: boolean;
  fetchSubFlowLogs?: (flowId: string) => void;
}

const LogDetailsDrawer: React.FC<LogDetailsDrawerProps> = ({
  open,
  onClose,
  log,
  subFlowLogs,
  isFetchingSubFlow,
  fetchSubFlowLogs,
}) => {
  const renderValue = (value: any) => {
    if (typeof value === 'object' && value !== null) {
      return (
        <pre style={{ fontSize: '0.8rem', whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
          {JSON.stringify(value, null, 2)}
        </pre>
      );
    }
    return String(value);
  };

  return (
    <Drawer
      anchor="right"
      variant="persistent"
      open={open}
      onClose={onClose}
      onClick={(e) => e.stopPropagation()} // Prevent clicks inside drawer from closing it
      PaperProps={{
        sx: {
          width: { xs: '90%', sm: 400, md: 500 },
          p: 2,
          position: 'absolute',
          top: 0,
          right: 0,
          height: '100%',
          boxShadow: '-2px 0 8px rgba(0,0,0,0.1)',
        }
      }}
      sx={{
        position: 'absolute',
        right: 0,
        top: 0,
        height: '100%',
        zIndex: 1200,
        pointerEvents: open ? 'auto' : 'none', // Pass through clicks when closed
        '& .MuiDrawer-root': {
          position: 'absolute'
        }
      }}
    >
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6">Log Details</Typography>
        <IconButton onClick={onClose}>
          <CloseIcon />
        </IconButton>
      </Box>
      <Divider sx={{ mb: 2 }} />
      <Box>
        {log ? (
          <Stack spacing={2}>
            <Paper variant="outlined" sx={{ p: 2 }}>
              <Typography variant="subtitle1" gutterBottom>
                Flow Info
              </Typography>
              <Stack spacing={1}>
                <Chip
                  label={`Flow: ${log.ContactFlowName}`}
                  size="small"
                  color="primary"
                  variant="outlined"
                />
                {subFlowLogs && subFlowLogs.length > 1 && (
                  <Chip
                    label={`${subFlowLogs.length} logs in this flow`}
                    size="small"
                    color="secondary"
                  />
                )}
                <Typography variant="body2" color="text.secondary">
                  <strong>First Timestamp:</strong> {new Date(log.Timestamp).toLocaleString()}
                </Typography>
                {subFlowLogs && subFlowLogs.length > 1 && (
                  <Typography variant="body2" color="text.secondary">
                    <strong>Last Timestamp:</strong>{' '}
                    {new Date(subFlowLogs[subFlowLogs.length - 1].Timestamp).toLocaleString()}
                  </Typography>
                )}
              </Stack>
            </Paper>

            {log.Parameters && (
              <Paper variant="outlined" sx={{ p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Parameters
                </Typography>
                {Object.entries(log.Parameters).map(([key, value]) => (
                  <Box key={key} sx={{ mb: 1 }}>
                    <Typography variant="body2">
                      <strong>{key}:</strong>
                    </Typography>
                    {renderValue(value)}
                  </Box>
                ))}
              </Paper>
            )}

            {log.Results && (
              <Paper variant="outlined" sx={{ p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Results
                </Typography>
                <Typography variant="body2">{log.Results}</Typography>
              </Paper>
            )}

            {log.ExternalResults && (
              <Paper variant="outlined" sx={{ p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  External Results
                </Typography>
                {renderValue(log.ExternalResults)}
              </Paper>
            )}

            {/* Display chunked logs for this flow node */}
            {subFlowLogs && subFlowLogs.length > 0 && (
              <Paper variant="outlined" sx={{ p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Flow Logs (Time-ordered)
                </Typography>
                <Box sx={{ maxHeight: 400, overflowY: 'auto' }}>
                  {subFlowLogs.map((subLog, index) => (
                    <Paper
                      key={index}
                      sx={{
                        p: 1.5,
                        my: 1,
                        backgroundColor: subLog.Results?.includes('Error') || subLog.Results?.includes('Failed')
                          ? '#FFEBEE'
                          : '#F5F5F5',
                        borderLeft: `3px solid ${subLog.Results?.includes('Error') || subLog.Results?.includes('Failed')
                            ? '#F44336'
                            : '#2196F3'
                          }`,
                      }}
                      variant="outlined"
                    >
                      <Stack spacing={0.5}>
                        <Typography variant="body2" fontWeight="bold">
                          {subLog.ContactFlowModuleType}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {new Date(subLog.Timestamp).toLocaleString()}
                        </Typography>
                        {subLog.Identifier && (
                          <Typography variant="caption" color="text.secondary">
                            ID: {subLog.Identifier}
                          </Typography>
                        )}
                        {subLog.Results && (
                          <Typography variant="caption" color="text.primary">
                            Result: {subLog.Results}
                          </Typography>
                        )}
                      </Stack>
                    </Paper>
                  ))}
                </Box>
              </Paper>
            )}

            {log.ContactFlowModuleType === 'InvokeFlowModule' && !subFlowLogs?.length && (
              <Paper variant="outlined" sx={{ p: 2 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Sub-Flow Logs
                </Typography>
                {isFetchingSubFlow ? (
                  <CircularProgress size={24} />
                ) : (
                  <Button
                    variant="outlined"
                    onClick={() => fetchSubFlowLogs?.(log.Parameters?.ContactFlowId)}
                  >
                    View Sub-Flow Logs
                  </Button>
                )}
              </Paper>
            )}
          </Stack>
        ) : (
          <Typography variant="body2" color="text.secondary">
            No log data available. Click on a node to see its details.
          </Typography>
        )}
      </Box>
    </Drawer>
  );
};

export default LogDetailsDrawer;


---------------------
/Users/ke-aicc/Downloads/files/src/pages/Settings.tsx
---------------------
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  Alert,
  CircularProgress,
  Autocomplete,
} from '@mui/material';
import { useConfig } from '@/contexts/ConfigContext';
import {
  fetchSSOCredentials,
  getCredentialsFromEnv,
  autoFetchSSOCredentials,
  getRegionFromProfile
} from '@/services/credentialService';
import { getAWSConnectService } from '@/services/awsConnectService';

const Settings: React.FC = () => {
  const { config, updateConfig, resetConfig } = useConfig();
  const [localConfig, setLocalConfig] = useState(config);
  const [saved, setSaved] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [warning, setWarning] = useState<string | null>(null);
  const [connectInstances, setConnectInstances] = useState<Array<{ id: string; alias: string }>>([]);
  const [loadingInstances, setLoadingInstances] = useState(false);

  const handleSave = () => {
    updateConfig(localConfig);
    setSaved(true);
    setError(null);
    setTimeout(() => setSaved(false), 3000);
  };

  const handleReset = () => {
    resetConfig();
    setLocalConfig(config);
    setError(null);
  };

  const handleFetchSSOCredentials = async () => {
    setLoading(true);
    setError(null);
    try {
      const credentials = await fetchSSOCredentials(localConfig.profile);
      setLocalConfig({
        ...localConfig,
        credentials,
      });
      setSaved(false);
      alert('SSO 자격 증명을 성공적으로 가져왔습니다. "저장" 버튼을 눌러 저장하세요.');
    } catch (err: any) {
      setError(err.message || 'SSO 자격 증명을 가져오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleLoadEnvCredentials = () => {
    const credentials = getCredentialsFromEnv();
    if (credentials) {
      setLocalConfig({
        ...localConfig,
        credentials,
      });
      setSaved(false);
      alert('환경 변수에서 자격 증명을 가져왔습니다. "저장" 버튼을 눌러 저장하세요.');
    } else {
      setError('환경 변수에서 자격 증명을 찾을 수 없습니다.');
    }
  };

  const handleFetchConnectInstances = async () => {
    if (!localConfig.credentials) {
      setError('먼저 AWS 자격 증명을 설정해주세요.');
      return;
    }

    setLoadingInstances(true);
    setError(null);
    try {
      const service = getAWSConnectService(localConfig);
      const instances = await service.listInstances();
      setConnectInstances(instances);

      if (instances.length === 1) {
        // Auto-select if only one instance
        setLocalConfig(prev => ({
          ...prev,
          instanceId: instances[0].id,
        }));
      }
    } catch (err: any) {
      setError(err.message || 'Connect 인스턴스를 가져오는데 실패했습니다.');
    } finally {
      setLoadingInstances(false);
    }
  };

  // Auto-fetch SSO credentials on component mount
  useEffect(() => {
    const autoLoad = async () => {
      setLoading(true);
      setWarning(null);

      try {
        const ssoData = await autoFetchSSOCredentials();

        if (ssoData) {
          setLocalConfig(prev => ({
            ...prev,
            credentials: ssoData.credentials,
            profile: ssoData.profile,
            region: ssoData.region,
          }));
          setSaved(false);
        } else {
          setWarning('AWS SSO 로그인 정보를 찾을 수 없습니다. 먼저 터미널에서 "aws sso login --profile your-profile"을 실행하거나 수동으로 자격 증명을 입력하세요.');
        }
      } catch (err) {
        setWarning('AWS SSO 자격 증명을 자동으로 가져오지 못했습니다. 수동으로 입력하세요.');
      } finally {
        setLoading(false);
      }
    };

    autoLoad();
  }, []); // Only run on mount

  // Update region when profile changes
  useEffect(() => {
    const updateRegion = async () => {
      if (localConfig.profile) {
        const region = await getRegionFromProfile(localConfig.profile);
        if (region && region !== localConfig.region) {
          setLocalConfig(prev => ({
            ...prev,
            region,
          }));
        }
      }
    };

    updateRegion();
  }, [localConfig.profile, localConfig.region]);

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        AWS 설정
      </Typography>

      {saved && (
        <Alert severity="success" sx={{ mb: 2 }}>
          설정이 저장되었습니다.
        </Alert>
      )}

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {warning && (
        <Alert severity="warning" sx={{ mb: 2 }} onClose={() => setWarning(null)}>
          {warning}
        </Alert>
      )}

      <Paper sx={{ p: 3, maxWidth: 800 }}>
        <Stack spacing={3}>
          {/* AWS Region - Read Only */}
          <TextField
            label="AWS Region"
            value={localConfig.region}
            fullWidth
            InputProps={{
              readOnly: true,
            }}
            helperText="리전은 AWS 프로필에서 자동으로 설정됩니다"
          />

          {/* Instance ID with Auto-fetch */}
          <Stack direction="column" spacing={1}>
            {connectInstances.length > 0 ? (
              <Autocomplete
                options={connectInstances}
                getOptionLabel={(option) => `${option.alias} (${option.id})`}
                value={connectInstances.find(inst => inst.id === localConfig.instanceId) || null}
                onChange={(event, newValue) => {
                  setLocalConfig({
                    ...localConfig,
                    instanceId: newValue?.id || '',
                  });
                }}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Connect Instance ID"
                    helperText="Connect API에서 가져온 인스턴스를 선택하세요"
                  />
                )}
              />
            ) : (
              <TextField
                label="Connect Instance ID"
                value={localConfig.instanceId}
                onChange={(e) => setLocalConfig({ ...localConfig, instanceId: e.target.value })}
                fullWidth
                helperText="예: 12345678-1234-1234-1234-123456789012"
              />
            )}
            <Button
              variant="outlined"
              size="small"
              onClick={handleFetchConnectInstances}
              disabled={loadingInstances || !localConfig.credentials}
            >
              {loadingInstances ? <CircularProgress size={20} /> : 'Connect 인스턴스 가져오기'}
            </Button>
          </Stack>

          {/* Environment */}
          <FormControl fullWidth>
            <InputLabel>Environment</InputLabel>
            <Select
              value={localConfig.environment}
              label="Environment"
              onChange={(e) => setLocalConfig({ ...localConfig, environment: e.target.value as any })}
            >
              <MenuItem value="dev">Development</MenuItem>
              <MenuItem value="stg">Staging</MenuItem>
              <MenuItem value="prd">Production</MenuItem>
              <MenuItem value="test">Test</MenuItem>
            </Select>
          </FormControl>

          {/* Log Group Name */}
          <TextField
            label="CloudWatch Log Group Name"
            value={localConfig.logGroupName}
            onChange={(e) => setLocalConfig({ ...localConfig, logGroupName: e.target.value })}
            fullWidth
            helperText="예: /aws/connect/your-instance"
          />

          {/* Credential Options */}
          <Typography variant="h6" sx={{ mt: 2 }}>
            인증 설정
          </Typography>

          {/* SSO Profile and Fetch Button */}
          <TextField
            label="AWS SSO Profile"
            value={localConfig.profile || ''}
            onChange={(e) => setLocalConfig({ ...localConfig, profile: e.target.value })}
            fullWidth
            helperText="백엔드에서 SSO 자격 증명을 가져올 프로필 이름"
          />

          <Stack direction="row" spacing={2}>
            <Button
              variant="outlined"
              onClick={handleFetchSSOCredentials}
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} /> : 'SSO 자격 증명 가져오기'}
            </Button>
            <Button
              variant="outlined"
              onClick={handleLoadEnvCredentials}
              disabled={loading}
            >
              환경 변수에서 가져오기
            </Button>
          </Stack>

          <Alert severity="info">
            <Typography variant="body2">
              <strong>SSO 자격 증명 사용 방법:</strong>
              <br />
              1. 백엔드 API 서버가 필요합니다 (package.json의 proxy 설정 확인)
              <br />
              2. 백엔드에서 <code>aws sso login --profile your-profile</code> 실행
              <br />
              3. 위 "SSO 자격 증명 가져오기" 버튼 클릭
              <br />
              <br />
              또는 환경 변수를 사용하려면 .env 파일에 다음을 설정하세요:
              <br />
              REACT_APP_AWS_ACCESS_KEY_ID=your_key
              <br />
              REACT_APP_AWS_SECRET_ACCESS_KEY=your_secret
            </Typography>
          </Alert>

          <Typography variant="subtitle2" sx={{ mt: 2, mb: 1 }}>
            또는 수동으로 자격 증명 입력:
          </Typography>

          <TextField
                label="Access Key ID"
                value={localConfig.credentials?.accessKeyId || ''}
                onChange={(e) =>
                  setLocalConfig({
                    ...localConfig,
                    credentials: {
                      ...localConfig.credentials!,
                      accessKeyId: e.target.value,
                    },
                  })
                }
                fullWidth
                type="password"
              />

              <TextField
                label="Secret Access Key"
                value={localConfig.credentials?.secretAccessKey || ''}
                onChange={(e) =>
                  setLocalConfig({
                    ...localConfig,
                    credentials: {
                      ...localConfig.credentials!,
                      secretAccessKey: e.target.value,
                    },
                  })
                }
                fullWidth
                type="password"
              />

              <TextField
                label="Session Token (선택사항)"
                value={localConfig.credentials?.sessionToken || ''}
                onChange={(e) =>
                  setLocalConfig({
                    ...localConfig,
                    credentials: {
                      ...localConfig.credentials!,
                      sessionToken: e.target.value,
                    },
                  })
                }
                fullWidth
                type="password"
              />

          {/* Action Buttons */}
          <Stack direction="row" spacing={2} sx={{ mt: 3 }}>
            <Button variant="contained" onClick={handleSave}>
              저장
            </Button>
            <Button variant="outlined" onClick={handleReset}>
              초기화
            </Button>
          </Stack>
        </Stack>
      </Paper>
    </Box>
  );
};

export default Settings;


---------------------
/Users/ke-aicc/Downloads/files/src/pages/XRayTraceViewer.tsx
---------------------
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import {
  Container,
  Paper,
  Box,
  Typography,
  Button,
  CircularProgress,
  Alert,
  Toolbar,
  IconButton,
  Tooltip,
  Chip,
  Stack,
} from '@mui/material';
import {
  ArrowBack as BackIcon,
  Fullscreen as FullscreenIcon,
  Download as DownloadIcon,
  Refresh as RefreshIcon,
} from '@mui/icons-material';
import ReactFlow, {
  Node,
  Edge,
  Controls,
  Background,
  MiniMap,
  useNodesState,
  useEdgesState,
  ReactFlowProvider,
} from 'react-flow-renderer';
import { useQuery } from '@tanstack/react-query';
import { getAWSConnectService } from '@/services/awsConnectService';
import XRayNode from '@/components/FlowNodes/XRayNode';
import LogDetailsDrawer from '@/components/LogDetailsDrawer/LogDetailsDrawer';
import { useConfig } from '@/contexts/ConfigContext';

const nodeTypes = {
  xraySegment: XRayNode,
  lambdaLog: XRayNode,
};

const XRayCanvas: React.FC<{
  nodes: Node[];
  edges: Edge[];
  onNodesChange: any;
  onEdgesChange: any;
  onNodeClick: any;
  nodeTypes: any;
}> = ({ nodes, edges, onNodesChange, onEdgesChange, onNodeClick, nodeTypes }) => {
  return (
    <ReactFlowProvider>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onNodeClick={onNodeClick}
        nodeTypes={nodeTypes}
        fitView
        attributionPosition="bottom-left"
      >
        <Background gap={12} size={1} />
        <Controls />
        <MiniMap
          nodeStrokeColor={(node) => {
            if (node.data?.error) return '#f44336';
            return '#4caf50';
          }}
          nodeColor={(node) => {
            if (node.data?.error) return '#ffebee';
            return '#e8f5e9';
          }}
          nodeBorderRadius={4}
        />
      </ReactFlow>
    </ReactFlowProvider>
  );
};

const XRayTraceViewerContent: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const xrayTraceId = searchParams.get('traceId');
  const contactId = searchParams.get('contactId');

  const { config, isConfigured } = useConfig();
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedLog, setSelectedLog] = useState<any | null>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);

  // Fetch X-Ray trace data
  const { data: xrayData, isLoading, error, refetch } = useQuery({
    queryKey: ['xrayTrace', xrayTraceId],
    queryFn: async () => {
      if (!isConfigured || !xrayTraceId) return null;
      const service = getAWSConnectService(config);
      return await service.getXRayTrace(xrayTraceId);
    },
    enabled: isConfigured && !!xrayTraceId,
  });

  // Build React Flow nodes and edges from X-Ray trace data
  useEffect(() => {
    if (!xrayData) return;

    const flowNodes: Node[] = [];
    const flowEdges: Edge[] = [];
    let yPosition = 0;

    // Process X-Ray segments
    xrayData.segments?.forEach((segment: any, index: number) => {
      const nodeId = segment.id;
      const isError = segment.error || segment.fault;

      // Main segment node
      flowNodes.push({
        id: nodeId,
        type: 'xraySegment',
        position: { x: index * 350, y: yPosition },
        data: {
          label: segment.name || 'Unknown',
          segmentData: segment,
          error: isError,
          duration: segment.end_time - segment.start_time,
          service: segment.origin || 'AWS',
        },
      });

      // Process subsegments
      segment.subsegments?.forEach((subsegment: any, subIndex: number) => {
        if (['Overhead', 'Dwell Time', 'Lambda', 'QueueTime', 'Initialization'].includes(subsegment.name)) {
          return; // Skip these subsegments
        }

        const subNodeId = subsegment.id;
        const subIsError = subsegment.error || subsegment.fault;

        flowNodes.push({
          id: subNodeId,
          type: 'xraySegment',
          position: { x: index * 350 + 300, y: yPosition + (subIndex * 120) },
          data: {
            label: subsegment.name || 'Unknown',
            segmentData: subsegment,
            error: subIsError,
            duration: subsegment.end_time - subsegment.start_time,
            service: subsegment.namespace || 'aws',
            operation: subsegment.aws?.operation,
            resource: subsegment.aws?.resource_names?.[0],
            httpMethod: subsegment.http?.request?.method,
            httpUrl: subsegment.http?.request?.url,
            httpStatus: subsegment.http?.response?.status,
          },
        });

        // Edge from parent to subsegment
        flowEdges.push({
          id: `${nodeId}-${subNodeId}`,
          source: nodeId,
          target: subNodeId,
          label: subsegment.aws?.operation || subsegment.http?.request?.method || '',
          type: 'smoothstep',
          animated: subIsError,
          style: { stroke: subIsError ? '#f44336' : '#4caf50' },
        });
      });

      // Connect parent segments
      if (segment.parent_id && index > 0) {
        const parentNode = flowNodes.find(n => n.id === segment.parent_id);
        if (parentNode) {
          flowEdges.push({
            id: `${segment.parent_id}-${nodeId}`,
            source: segment.parent_id,
            target: nodeId,
            type: 'smoothstep',
          });
        }
      }
    });

    // Add Lambda CloudWatch Logs if available
    xrayData.lambdaLogs?.forEach((log: any, index: number) => {
      const logNodeId = `log_${log.timestamp}_${index}`;
      const isError = log.level === 'ERROR' || log.level === 'WARN';

      flowNodes.push({
        id: logNodeId,
        type: 'lambdaLog',
        position: { x: 0, y: yPosition + 400 + (index * 100) },
        data: {
          label: log.level || 'INFO',
          logData: log,
          error: isError,
          message: log.message,
          timestamp: log.timestamp,
        },
      });

      if (index > 0) {
        flowEdges.push({
          id: `log_${index - 1}_${index}`,
          source: `log_${xrayData.lambdaLogs[index - 1].timestamp}_${index - 1}`,
          target: logNodeId,
          type: 'smoothstep',
        });
      }
    });

    setNodes(flowNodes);
    setEdges(flowEdges);
  }, [xrayData, setNodes, setEdges]);

  const handleNodeClick = useCallback((_event: React.MouseEvent, node: Node) => {
    setSelectedLog(node.data.segmentData || node.data.logData);
    setDrawerOpen(true);
  }, []);

  const handleBack = () => {
    navigate(-1);
  };

  if (!isConfigured) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4 }}>
        <Alert severity="warning">
          AWS configuration is required. Please configure your settings first.
        </Alert>
        <Button startIcon={<BackIcon />} onClick={() => navigate('/settings')} sx={{ mt: 2 }}>
          Go to Settings
        </Button>
      </Container>
    );
  }

  if (!xrayTraceId) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4 }}>
        <Alert severity="error">X-Ray Trace ID is required</Alert>
        <Button startIcon={<BackIcon />} onClick={handleBack} sx={{ mt: 2 }}>
          Go Back
        </Button>
      </Container>
    );
  }

  return (
    <Container maxWidth={false} disableGutters sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* Header Toolbar */}
      <Paper elevation={2} sx={{ borderRadius: 0 }}>
        <Toolbar sx={{ gap: 2 }}>
          <IconButton edge="start" onClick={handleBack}>
            <BackIcon />
          </IconButton>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flex: 1 }}>
            <Typography variant="h6" component="h1" noWrap>
              AWS X-Ray Trace
            </Typography>
            <Chip label={xrayTraceId} size="small" color="primary" sx={{ fontFamily: 'monospace' }} />
            {contactId && <Chip label={`Contact: ${contactId}`} size="small" variant="outlined" />}
          </Box>
          <Stack direction="row" spacing={1}>
            <Tooltip title="Refresh">
              <IconButton onClick={() => refetch()}>
                <RefreshIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Fullscreen">
              <IconButton>
                <FullscreenIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download">
              <IconButton>
                <DownloadIcon />
              </IconButton>
            </Tooltip>
          </Stack>
        </Toolbar>
      </Paper>

      {/* Main Content */}
      <Box sx={{ flex: 1, position: 'relative', bgcolor: '#fafafa' }}>
        {isLoading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
            <CircularProgress />
          </Box>
        )}

        {error && (
          <Box sx={{ p: 3 }}>
            <Alert severity="error">
              Failed to load X-Ray trace: {error instanceof Error ? error.message : 'Unknown error'}
            </Alert>
          </Box>
        )}

        {!isLoading && !error && nodes.length === 0 && (
          <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
            <Typography variant="h6" color="text.secondary">
              No trace data available
            </Typography>
          </Box>
        )}

        {!isLoading && !error && nodes.length > 0 && (
          <XRayCanvas
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onNodeClick={handleNodeClick}
            nodeTypes={nodeTypes}
          />
        )}
      </Box>

      {/* Details Drawer */}
      <LogDetailsDrawer
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
        log={selectedLog}
      />
    </Container>
  );
};

const XRayTraceViewer: React.FC = () => {
  return <XRayTraceViewerContent />;
};

export default XRayTraceViewer;


---------------------
/Users/ke-aicc/Downloads/files/src/pages/ContactFlowViewer.tsx
---------------------
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Container,
  Paper,
  Box,
  Typography,
  Button,
  CircularProgress,
  Alert,
  Toolbar,
  IconButton,
  Tooltip,
  Chip,
  Stack,
  TextField,
  InputAdornment,
} from '@mui/material';
import {
  ArrowBack as BackIcon,
  Fullscreen as FullscreenIcon,
  Download as DownloadIcon,
  Timeline as TimelineIcon,
  Search as SearchIcon,
  Refresh as RefreshIcon,
  Settings as SettingsIcon,
} from '@mui/icons-material';
import ReactFlow, {
  Node,
  Edge,
  Controls,
  Background,
  MiniMap,
  useNodesState,
  useEdgesState,
  MarkerType,
  ReactFlowProvider,
} from 'react-flow-renderer';
import { useQuery } from '@tanstack/react-query';
import { getAWSConnectService } from '@/services/awsConnectService';
import { FlowBuilderService } from '@/services/flowBuilderService';
import { ContactLog } from '@/types/contact.types';
import CustomNode from '@/components/FlowNodes/CustomNode';
import TranscriptPanel from '@/components/TranscriptPanel/TranscriptPanel';
import LogDetailsDrawer from '@/components/LogDetailsDrawer/LogDetailsDrawer';
import { useConfig } from '@/contexts/ConfigContext';


const nodeTypes = {
  custom: CustomNode,
};

const FlowCanvas: React.FC<{
  nodes: Node[];
  edges: Edge[];
  onNodesChange: any;
  onEdgesChange: any;
  onNodeClick: any;
  nodeTypes: any;
}> = ({ nodes, edges, onNodesChange, onEdgesChange, onNodeClick, nodeTypes }) => {
  return (
    <ReactFlowProvider>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onNodeClick={onNodeClick}
        nodeTypes={nodeTypes}
        fitView
        attributionPosition="bottom-left"
      >
        <Background gap={12} size={1} />
        <Controls />
        <MiniMap
          nodeStrokeColor={(node) => {
            if (node.data?.error) return '#f44336';
            if (node.type === 'input') return '#4caf50';
            if (node.type === 'output') return '#2196f3';
            return '#888';
          }}
          nodeColor={(node) => {
            if (node.data?.error) return '#ffebee';
            return '#f5f5f5';
          }}
          nodeBorderRadius={4}
        />
      </ReactFlow>
    </ReactFlowProvider>
  );
};

const ContactFlowViewerContent: React.FC = () => {
  const { contactId } = useParams<{ contactId: string }>();
  const navigate = useNavigate();
  const { config, isConfigured } = useConfig();
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedLog, setSelectedLog] = useState<ContactLog | null>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [transcriptOpen, setTranscriptOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [zoomLevel, setZoomLevel] = useState(1);
  const [subFlowLogs, setSubFlowLogs] = useState<ContactLog[]>([]);
  const [isFetchingSubFlow, setIsFetchingSubFlow] = useState(false);



  const fetchSubFlowLogs = useCallback(async (flowId: string) => {
    if (!contactId) return;

    setIsFetchingSubFlow(true);
    try {
      const service = getAWSConnectService(config);
      const details = await service.getContactDetails(contactId);
      const startTime = new Date(details.initiationTimestamp);
      startTime.setHours(startTime.getHours() - 1);
      const endTime = details.disconnectTimestamp
        ? new Date(details.disconnectTimestamp)
        : new Date();
      endTime.setHours(endTime.getHours() + 1);

      const logs = await service.getContactLogs(flowId, startTime, endTime);
      setSubFlowLogs(logs);
    } catch (error) {
      console.error('Error fetching sub-flow logs:', error);
      setSubFlowLogs([]);
    } finally {
      setIsFetchingSubFlow(false);
    }
  }, [contactId, config]);

  const { data: queryData, isLoading, error, refetch } = useQuery({
    queryKey: ['contact-flow', contactId, config.credentials?.accessKeyId],
    queryFn: async () => {
      if (!contactId) throw new Error('Contact ID is required');

      // Initialize service with current config
      const service = getAWSConnectService(config);

      // Get contact details
      const details = await service.getContactDetails(contactId);

      // Calculate time range
      const startTime = new Date(details.initiationTimestamp);
      startTime.setHours(startTime.getHours() - 1);
      const endTime = details.disconnectTimestamp
        ? new Date(details.disconnectTimestamp)
        : new Date();
      endTime.setHours(endTime.getHours() + 1);

      // Fetch logs
      const [contactLogs, transcript] = await Promise.all([
        service.getContactLogs(contactId, startTime, endTime),
        service.getTranscript(contactId, startTime),
      ]);

      // Build flow for main view (with filtering)
      const flowBuilder = new FlowBuilderService(contactLogs, { filterModules: true });
      const flowData = flowBuilder.buildFlow();

      // Add transcript if available
      if (transcript.length > 0) {
        flowBuilder.addTranscript(transcript);
        flowData.transcript = transcript;
      }

      return { flowData, originalLogs: contactLogs }; // Return both
    },
    enabled: !!contactId,
    retry: 2,
  });

  // Extract flowData for convenience
  const flowData = queryData?.flowData;

  // Update nodes and edges when flow data changes
  useEffect(() => {
    if (flowData) {

      // Convert to React Flow format
      const flowNodes: Node[] = flowData.nodes.map((node) => ({
        id: node.id,
        type: node.type || 'custom',
        position: node.position,
        data: {
          ...node.data,
          isMainView: true, // Main View임을 CustomNode에 전달
        },
        style: node.style,
      }));

      const flowEdges: Edge[] = flowData.edges.map((edge) => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        sourceHandle: edge.sourceHandle,
        targetHandle: edge.targetHandle,
        type: edge.type || 'smoothstep',
        animated: edge.animated || false,
        style: edge.style || {},
        label: edge.label,
        markerEnd: {
          type: MarkerType.ArrowClosed,
        },
      }));

      setNodes(flowNodes);
      setEdges(flowEdges);
    }
  }, [flowData, setNodes, setEdges]);

  // Handle node click - Navigate to flow detail page
  const onNodeClick = useCallback(
    (event: React.MouseEvent, node: Node) => {
      event.stopPropagation(); // Prevent closing drawer when clicking a node
      const flowName = node.data?.label as string;
      const timeRange = node.data?.timeRange as { start: string, end: string } | undefined;

      if (flowName && timeRange && queryData?.originalLogs) {
        // Filter originalLogs to get all logs for this flow
        // We need to extend the time range to include any MOD_ flows invoked during this flow
        const allLogs = queryData.originalLogs;
        const startTime = new Date(timeRange.start).getTime();

        // Find the start index of this flow
        const startIndex = allLogs.findIndex(log => new Date(log.Timestamp).getTime() >= startTime);

        if (startIndex !== -1) {
          // Find the end index: where the next different ContactFlowName (not MOD_) starts
          let endIndex = startIndex;
          for (let i = startIndex; i < allLogs.length; i++) {
            const log = allLogs[i];
            const isModuleLog = log.ContactFlowName?.startsWith('MOD_');
            const isInvokeOrReturn = log.ContactFlowModuleType === 'InvokeFlowModule' ||
              log.ContactFlowModuleType === 'ReturnFromFlowModule';

            // Include: same flow, module logs, or invoke/return module types
            if (log.ContactFlowName === flowName || isModuleLog || isInvokeOrReturn) {
              endIndex = i;
            } else {
              // Different flow name (not MOD_) - stop here
              break;
            }
          }

          const nodeOriginalLogs = allLogs.slice(startIndex, endIndex + 1);

          // Navigate to flow detail page with the unfiltered logs for that chunk
          navigate(`/contact-flow/${contactId}/flow/${encodeURIComponent(flowName)}`, {
            state: {
              chunkedLogs: nodeOriginalLogs, // Pass the unfiltered logs including MOD_ flows
              flowName,
              contactId,
            },
          });
        }
      } else {
        // Fallback: try to find log by node_id for backward compatibility
        const log = queryData?.flowData?.logs.find((l) => l.node_id === node.id);
        if (log) {
          setSelectedLog(log);
          setDrawerOpen(true);
          setSubFlowLogs([]); // Reset sub-flow logs

          if (log.ContactFlowModuleType === 'InvokeFlowModule' && log.Parameters?.ContactFlowId) {
            fetchSubFlowLogs(log.Parameters.ContactFlowId);
          }
        }
      }
    },
    [queryData, contactId, navigate, fetchSubFlowLogs]
  );

  // Handle export
  const handleExport = () => {
    if (!flowData) return;

    const dataStr = JSON.stringify(flowData, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

    const exportFileDefaultName = `contact-flow-${contactId}.json`;

    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
  };

  // Handle search with deep search support
  const handleSearch = (term: string) => {
    setSearchTerm(term);

    if (term) {
      const filteredNodes = nodes.map((node) => {
        const lowerTerm = term.toLowerCase();
        const label = node.data?.label || '';
        const parameters = node.data?.parameters || {};
        const timeRange = node.data?.timeRange as { start: string; end: string } | undefined;

        // Basic search (current node)
        let matches =
          label.toLowerCase().includes(lowerTerm) ||
          JSON.stringify(parameters).toLowerCase().includes(lowerTerm);

        // Deep search (search in all logs within this flow's time range)
        if (!matches && timeRange && queryData?.originalLogs) {
          const allLogs = queryData.originalLogs;
          const startTime = new Date(timeRange.start).getTime();
          const endTime = new Date(timeRange.end).getTime();

          // Find logs within this flow's time range
          matches = allLogs.some((log: ContactLog) => {
            const logTime = new Date(log.Timestamp).getTime();

            // Check if log is within time range
            if (logTime >= startTime && logTime <= endTime) {
              const logLabel = log.ContactFlowModuleType || '';
              const logParams = log.Parameters || {};
              const logId = log.Identifier || '';
              const logResults = log.Results || '';
              const logExternalResults = log.ExternalResults || {};

              return (
                logLabel.toLowerCase().includes(lowerTerm) ||
                logId.toLowerCase().includes(lowerTerm) ||
                logResults.toLowerCase().includes(lowerTerm) ||
                JSON.stringify(logParams).toLowerCase().includes(lowerTerm) ||
                JSON.stringify(logExternalResults).toLowerCase().includes(lowerTerm)
              );
            }
            return false;
          });
        }

        return {
          ...node,
          style: {
            ...node.style,
            opacity: matches ? 1 : 0.3,
          },
        };
      });

      setNodes(filteredNodes);
    } else {
      // Reset opacity
      const resetNodes = nodes.map((node) => ({
        ...node,
        style: {
          ...node.style,
          opacity: 1,
        },
      }));

      setNodes(resetNodes);
    }
  };

  if (!contactId) {
    return (
      <Container>
        <Alert severity="error">No Contact ID provided</Alert>
        <Button onClick={() => navigate('/')} startIcon={<BackIcon />}>
          Back to Dashboard
        </Button>
      </Container>
    );
  }

  if (!isConfigured || !config.credentials) {
    return (
      <Container sx={{ mt: 4 }}>
        <Alert severity="warning" sx={{ mb: 2 }}>
          AWS 자격 증명이 설정되지 않았습니다. Settings 페이지에서 자격 증명을 설정해주세요.
        </Alert>
        <Stack direction="row" spacing={2}>
          <Button
            variant="contained"
            onClick={() => navigate('/settings')}
            startIcon={<SettingsIcon />}
          >
            Settings로 이동
          </Button>
          <Button
            variant="outlined"
            onClick={() => navigate('/')}
            startIcon={<BackIcon />}
          >
            Dashboard로 돌아가기
          </Button>
        </Stack>
      </Container>
    );
  }

  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="80vh"
      >
        <CircularProgress />
        <Typography sx={{ ml: 2 }}>Loading contact flow...</Typography>
      </Box>
    );
  }

  if (error) {
    return (
      <Container>
        <Alert severity="error" sx={{ mb: 2 }}>
          Error loading contact flow: {(error as Error).message}
        </Alert>
        <Button onClick={() => navigate('/')} startIcon={<BackIcon />}>
          Back to Dashboard
        </Button>
      </Container>
    );
  }

  return (
    <Box
      sx={{ height: '100vh', display: 'flex', flexDirection: 'column', position: 'relative' }}
      onClick={() => setDrawerOpen(false)} // Close drawer on click outside
    >
      {/* Toolbar */}
      <Paper elevation={1} sx={{ zIndex: 10 }}>
        <Toolbar>
          <IconButton edge="start" onClick={() => navigate('/')}>
            <BackIcon />
          </IconButton>
          <Typography variant="h6" sx={{ flexGrow: 1, ml: 2 }}>
            Contact Flow: {contactId}
          </Typography>

          {/* Search */}
          <TextField
            size="small"
            placeholder="Search nodes..."
            value={searchTerm}
            onChange={(e) => handleSearch(e.target.value)}
            sx={{ mr: 2, width: 250 }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />

          {/* Actions */}
          <Stack direction="row" spacing={1}>
            <Tooltip title="Refresh">
              <IconButton onClick={() => refetch()}>
                <RefreshIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="View Transcript">
              <IconButton onClick={() => setTranscriptOpen(true)}>
                <TimelineIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Export JSON">
              <IconButton onClick={handleExport}>
                <DownloadIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Fullscreen">
              <IconButton onClick={() => document.documentElement.requestFullscreen()}>
                <FullscreenIcon />
              </IconButton>
            </Tooltip>
          </Stack>
        </Toolbar>
      </Paper>

      {/* Flow Statistics */}
      <Paper elevation={0} sx={{ p: 1, borderBottom: 1, borderColor: 'divider' }}>
        <Stack direction="row" spacing={2} alignItems="center">
          <Chip
            label={`Nodes: ${nodes.length}`}
            size="small"
            color="primary"
            variant="outlined"
          />
          <Chip
            label={`Duration: ${flowData?.logs[flowData.logs.length - 1]?.Duration || 'N/A'}`}
            size="small"
            color="secondary"
            variant="outlined"
          />
          <Chip
            label={`Errors: ${nodes.filter(n => n.data.error).length}`}
            size="small"
            color={nodes.filter(n => n.data.error).length > 0 ? 'error' : 'default'}
            variant="outlined"
          />
        </Stack>
      </Paper>

      {/* React Flow Canvas */}
      <Box sx={{ flex: 1 }}>
        <FlowCanvas
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onNodeClick={onNodeClick}
          nodeTypes={nodeTypes}
        />
      </Box>

      {/* Log Details Drawer */}
      <LogDetailsDrawer
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
        log={selectedLog}
        subFlowLogs={subFlowLogs}
        isFetchingSubFlow={isFetchingSubFlow}
        fetchSubFlowLogs={fetchSubFlowLogs}
      />

      {/* Transcript Panel */}
      <TranscriptPanel
        open={transcriptOpen}
        onClose={() => setTranscriptOpen(false)}
        transcript={flowData?.transcript || []}
      />
    </Box>
  );
};

const ContactFlowViewer: React.FC = () => {
  return (
    <ContactFlowViewerContent />
  );
};

export default ContactFlowViewer;

---------------------
/Users/ke-aicc/Downloads/files/src/pages/Dashboard.tsx
---------------------
import React, { useState } from 'react';
import {
  Container,
  Grid,
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Box,
  Paper,
  IconButton,
  InputAdornment,
  Alert,
  Chip,
  Stack,
  Divider,
  CircularProgress,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  SelectChangeEvent,
} from '@mui/material';
import {
  Search as SearchIcon,
  PlayArrow as PlayIcon,
  History as HistoryIcon,
  CloudDownload as CloudIcon,
  Settings as SettingsIcon,
  Timeline as TimelineIcon,
  Phone as PhoneIcon,
  Person as PersonIcon,
  AccountTree as FlowIcon,
  Error as ErrorIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import dayjs from 'dayjs';
import { useQuery } from '@tanstack/react-query';
import { ContactDetails } from '@/types/contact.types';
import { useConfig } from '@/contexts/ConfigContext';
import {
  searchCustomer,
  searchAgent,
  searchContactFlow,
  searchDNIS,
  searchLambdaError,
  detectSearchType,
} from '@/services/searchService';

type SearchType = 'ContactId' | 'Customer' | 'Agent' | 'ContactFlow' | 'DNIS' | 'LambdaError' | 'History';

const Dashboard: React.FC = () => {
  const navigate = useNavigate();
  const { config, isConfigured } = useConfig();
  const [searchType, setSearchType] = useState<SearchType>('ContactId');
  const [searchValue, setSearchValue] = useState('');
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [searchResults, setSearchResults] = useState<ContactDetails[]>([]);
  const [searchError, setSearchError] = useState<string | null>(null);

  // Statistics query
  const { data: stats } = useQuery({
    queryKey: ['dashboard-stats'],
    queryFn: async () => {
      // This would be replaced with actual API call
      return {
        totalContacts: 1234,
        averageHandleTime: 245,
        todayContacts: 89,
        activeAgents: 12,
      };
    },
    refetchInterval: 30000, // Refresh every 30 seconds
  });

  const handleSearch = async () => {
    // Validation
    if (searchType !== 'LambdaError' && searchType !== 'History') {
      if (!searchValue.trim()) {
        setSearchError(`Please enter a ${searchType}`);
        return;
      }
    }

    // Check config
    if (!config.credentials) {
      setSearchError('Please configure AWS credentials in Settings first');
      return;
    }

    // Add to recent searches
    if (searchValue) {
      setRecentSearches(prev => {
        const updated = [searchValue, ...prev.filter(val => val !== searchValue)];
        return updated.slice(0, 5);
      });
    }

    setSearchError(null);

    // For ContactId, navigate directly
    if (searchType === 'ContactId') {
      navigate(`/contact-flow/${searchValue}`);
      return;
    }

    // For History, show placeholder message
    if (searchType === 'History') {
      setSearchError('History feature will be implemented to show previously viewed contact flows.');
      return;
    }

    // For other types, call backend API
    try {
      setSearchResults([]);

      let result;
      // Determine instance alias from config
      const instanceAlias = config.instanceId ? 'kal-servicecenter' : 'kal-servicecenter'; // TODO: get from actual instance

      switch (searchType) {
        case 'Customer': {
          const detectedType = detectSearchType(searchValue, 'Customer');
          if (detectedType === 'unknown') {
            setSearchError('Invalid customer search value. Use Phone Number (E.164), 32-char Profile ID, or 12-char Skypass Number');
            return;
          }
          result = await searchCustomer(searchValue, detectedType as 'phone' | 'profileId' | 'skypass', config);
          break;
        }

        case 'Agent': {
          const detectedType = detectSearchType(searchValue, 'Agent') as 'uuid' | 'email' | 'name';
          result = await searchAgent(searchValue, detectedType, config);
          break;
        }

        case 'ContactFlow': {
          result = await searchContactFlow(searchValue, config, instanceAlias);
          break;
        }

        case 'DNIS': {
          result = await searchDNIS(searchValue, config, instanceAlias);
          break;
        }

        case 'LambdaError': {
          result = await searchLambdaError(config);
          break;
        }

        default:
          setSearchError('Unknown search type');
          return;
      }

      // Convert search results to ContactDetails format
      const contactDetails: ContactDetails[] = result.contacts.map(contact => ({
        contactId: contact.contactId,
        instanceId: config.instanceId,
        initiationTimestamp: contact.initiationTimestamp || contact.timestamp || new Date().toISOString(),
        channel: contact.channel || 'UNKNOWN',
        contactFlowName: searchType,
      }));

      setSearchResults(contactDetails);

      if (contactDetails.length === 0) {
        setSearchError('No contacts found for the given search criteria');
      }
    } catch (error) {
      console.error('Search error:', error);
      setSearchError((error as Error).message || 'Failed to search. Make sure the backend server is running (npm run server)');
    }
  };

  const handleRecentSearch = (id: string) => {
    setSearchValue(id);
    navigate(`/contact-flow/${id}`);
  };

  const getSearchPlaceholder = (): string => {
    switch (searchType) {
      case 'ContactId':
        return 'Enter Contact ID (UUID)';
      case 'Customer':
        return 'Enter Phone Number (+821012341234), Customer Profile ID, or Skypass Number';
      case 'Agent':
        return 'Enter Agent ID, Name, or Email';
      case 'ContactFlow':
        return 'Enter Contact Flow Name (e.g., 05_CustomerQueue)';
      case 'DNIS':
        return 'Enter DNIS (e.g., +82269269240)';
      case 'LambdaError':
        return 'Search for Lambda errors in the last 48 hours';
      case 'History':
        return 'View saved contact flow history';
      default:
        return 'Enter search value';
    }
  };

  const getSearchHelperText = (): string => {
    switch (searchType) {
      case 'ContactId':
        return 'UUID format required';
      case 'Customer':
        return 'Phone Number (E.164), 32-char Profile ID, or 12-char Skypass Number';
      case 'Agent':
        return 'UUID, Full Name (한글/영문), or Email format';
      case 'ContactFlow':
        return 'Case-sensitive flow name';
      case 'DNIS':
        return 'E.164 format (e.g., +82269269240)';
      case 'LambdaError':
        return 'Automatically searches CloudWatch Logs for errors';
      case 'History':
        return 'Shows previously searched contact flows';
      default:
        return '';
    }
  };

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h4" gutterBottom sx={{ mb: 3 }}>
        AWS Connect Contact Tracer
      </Typography>

      {/* Quick Search Card */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            Advanced Search
          </Typography>
          <Grid container spacing={2}>
            <Grid item xs={12} md={4}>
              <FormControl fullWidth>
                <InputLabel>Search Type</InputLabel>
                <Select
                  value={searchType}
                  label="Search Type"
                  onChange={(e: SelectChangeEvent) => {
                    setSearchType(e.target.value as SearchType);
                    setSearchValue('');
                  }}
                >
                  <MenuItem value="ContactId">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <SearchIcon fontSize="small" />
                      <span>Contact ID</span>
                    </Stack>
                  </MenuItem>
                  <MenuItem value="Customer">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <PersonIcon fontSize="small" />
                      <span>Customer</span>
                    </Stack>
                  </MenuItem>
                  <MenuItem value="Agent">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <PersonIcon fontSize="small" />
                      <span>Agent</span>
                    </Stack>
                  </MenuItem>
                  <MenuItem value="ContactFlow">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <FlowIcon fontSize="small" />
                      <span>Contact Flow</span>
                    </Stack>
                  </MenuItem>
                  <MenuItem value="DNIS">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <PhoneIcon fontSize="small" />
                      <span>DNIS</span>
                    </Stack>
                  </MenuItem>
                  <MenuItem value="LambdaError">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <ErrorIcon fontSize="small" />
                      <span>Lambda Error</span>
                    </Stack>
                  </MenuItem>
                  <MenuItem value="History">
                    <Stack direction="row" spacing={1} alignItems="center">
                      <HistoryIcon fontSize="small" />
                      <span>History</span>
                    </Stack>
                  </MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={8}>
              <TextField
                fullWidth
                variant="outlined"
                placeholder={getSearchPlaceholder()}
                value={searchValue}
                onChange={(e) => setSearchValue(e.target.value)}
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    handleSearch();
                  }
                }}
                helperText={getSearchHelperText()}
                disabled={searchType === 'LambdaError' || searchType === 'History'}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <SearchIcon />
                    </InputAdornment>
                  ),
                }}
              />
            </Grid>
            <Grid item xs={12}>
              <Button
                variant="contained"
                size="large"
                fullWidth
                onClick={handleSearch}
                startIcon={<PlayIcon />}
              >
                Search
              </Button>
            </Grid>
          </Grid>

          {/* Search Error */}
          {searchError && (
            <Alert severity="warning" sx={{ mt: 2 }} onClose={() => setSearchError(null)}>
              {searchError}
            </Alert>
          )}

          {/* Recent Searches */}
          {recentSearches.length > 0 && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="caption" color="textSecondary">
                Recent Searches:
              </Typography>
              <Stack direction="row" spacing={1} sx={{ mt: 1 }}>
                {recentSearches.map((id) => (
                  <Chip
                    key={id}
                    label={id}
                    onClick={() => handleRecentSearch(id)}
                    icon={<HistoryIcon />}
                    variant="outlined"
                    size="small"
                  />
                ))}
              </Stack>
            </Box>
          )}
        </CardContent>
      </Card>

      {/* Statistics Cards */}
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card className="hover-card">
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                Total Contacts
              </Typography>
              <Typography variant="h4">
                {stats?.totalContacts || '-'}
              </Typography>
              <Typography variant="caption" color="textSecondary">
                Last 24 hours
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card className="hover-card">
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                Avg Handle Time
              </Typography>
              <Typography variant="h4">
                {stats?.averageHandleTime ? `${Math.floor(stats.averageHandleTime / 60)}:${(stats.averageHandleTime % 60).toString().padStart(2, '0')}` : '-'}
              </Typography>
              <Typography variant="caption" color="textSecondary">
                Minutes
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card className="hover-card">
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                Today's Contacts
              </Typography>
              <Typography variant="h4">
                {stats?.todayContacts || '-'}
              </Typography>
              <Typography variant="caption" color="success.main">
                +12% from yesterday
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card className="hover-card">
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                Active Agents
              </Typography>
              <Typography variant="h4">
                {stats?.activeAgents || '-'}
              </Typography>
              <Typography variant="caption" color="textSecondary">
                Currently online
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Search Results */}
      {searchResults.length > 0 && (
        <Box sx={{ mt: 3 }}>
          <Typography variant="h6" gutterBottom>
            Search Results ({searchResults.length})
          </Typography>
          <Grid container spacing={2}>
            {searchResults.map((contact) => (
              <Grid item xs={12} key={contact.contactId}>
                <Card
                  sx={{ cursor: 'pointer', '&:hover': { boxShadow: 3 } }}
                  onClick={() => navigate(`/contact-flow/${contact.contactId}`)}
                >
                  <CardContent>
                    <Typography variant="body1" component="div">
                      <strong>Contact ID:</strong> {contact.contactId}
                    </Typography>
                    <Typography color="text.secondary">
                      <strong>Flow Name:</strong> {contact.contactFlowName || 'N/A'}
                    </Typography>
                    <Typography color="text.secondary">
                      <strong>Initiation:</strong> {dayjs(contact.initiationTimestamp).format('YYYY-MM-DD HH:mm:ss')}
                    </Typography>
                    <Chip label={contact.channel} size="small" sx={{ mt: 1 }} />
                  </CardContent>
                </Card>
              </Grid>
            ))}
          </Grid>
        </Box>
      )}

      {/* Quick Actions */}
      <Box sx={{ mt: 3 }}>
        <Typography variant="h6" gutterBottom>
          Quick Actions
        </Typography>
        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={3}>
            <Paper
              sx={{
                p: 2,
                textAlign: 'center',
                cursor: 'pointer',
                '&:hover': { bgcolor: 'action.hover' },
              }}
              onClick={() => navigate('/logs')}
            >
              <TimelineIcon sx={{ fontSize: 40, color: 'primary.main' }} />
              <Typography variant="subtitle1" sx={{ mt: 1 }}>
                View Logs
              </Typography>
            </Paper>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Paper
              sx={{
                p: 2,
                textAlign: 'center',
                cursor: 'pointer',
                '&:hover': { bgcolor: 'action.hover' },
              }}
              onClick={() => navigate('/contact-flow')}
            >
              <CloudIcon sx={{ fontSize: 40, color: 'primary.main' }} />
              <Typography variant="subtitle1" sx={{ mt: 1 }}>
                Flow Viewer
              </Typography>
            </Paper>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Paper
              sx={{
                p: 2,
                textAlign: 'center',
                cursor: 'pointer',
                '&:hover': { bgcolor: 'action.hover' },
              }}
              onClick={() => window.open('/api/export', '_blank')}
            >
              <CloudIcon sx={{ fontSize: 40, color: 'primary.main' }} />
              <Typography variant="subtitle1" sx={{ mt: 1 }}>
                Export Data
              </Typography>
            </Paper>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Paper
              sx={{
                p: 2,
                textAlign: 'center',
                cursor: 'pointer',
                '&:hover': { bgcolor: 'action.hover' },
              }}
              onClick={() => navigate('/settings')}
            >
              <SettingsIcon sx={{ fontSize: 40, color: 'primary.main' }} />
              <Typography variant="subtitle1" sx={{ mt: 1 }}>
                Settings
              </Typography>
            </Paper>
          </Grid>
        </Grid>
      </Box>

      {/* Info Alert */}
      <Alert severity="info" sx={{ mt: 3 }}>
        <Typography variant="subtitle2">
          <strong>Tip:</strong> You can use Contact ID from AWS Connect to trace the complete flow, 
          including all module executions, Lambda invocations, and customer interactions.
        </Typography>
      </Alert>
    </Container>
  );
};

export default Dashboard;


---------------------
/Users/ke-aicc/Downloads/files/src/pages/ModuleDetailViewer.tsx
---------------------
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import {
  Container,
  Box,
  Typography,
  Button,
  Alert,
  Paper,
  Toolbar,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Chip,
  Stack,
  Divider,
  TextField,
  InputAdornment,
} from '@mui/material';
import {
  ArrowBack as BackIcon,
  Download as DownloadIcon,
  CheckCircle as SuccessIcon,
  Error as ErrorIcon,
  AccessTime as TimeIcon,
  VerticalSplit as VerticalSplitIcon,
  Search as SearchIcon,
} from '@mui/icons-material';
import ReactFlow, {
  Node as ReactFlowNode,
  Edge,
  Controls,
  Background,
  MiniMap,
  useNodesState,
  useEdgesState,
  MarkerType,
  ReactFlowProvider,
  Position,
} from 'react-flow-renderer';
import { ContactLog } from '@/types/contact.types';
import CustomNode from '@/components/FlowNodes/CustomNode';
import { useConfig } from '@/contexts/ConfigContext';
import { enrichCheckAttributeLogs } from '@/utils/logProcessor';

const nodeTypes = {
  custom: (props: any) => <CustomNode {...props} isMainView={false} />,
};

interface LocationState {
  chunkedLogs?: ContactLog[];
  moduleName?: string;
  contactId?: string;
  flowName?: string;
}

// 헬퍼 함수: 연속되는 SetAttributes 로그를 병합합니다.
const consolidateSetAttributesLogs = (logs: ContactLog[]): ContactLog[] => {
  if (!logs || logs.length === 0) {
    return [];
  }

  const consolidated: ContactLog[] = [];
  let group: ContactLog[] = [];
  let currentGroupType: string | null = null;
  let getUserInputGroup: ContactLog[] = [];
  let currentGetUserInputIdentifier: string | null = null;
  let invokeExternalGroup: ContactLog[] = [];
  let currentInvokeExternalIdentifier: string | null = null;

  const mergeGroup = () => {
    if (group.length === 0) return;

    if (group.length === 1) {
      consolidated.push(group[0]);
    } else {
      const baseLog = { ...group[0] };
      const isCheckAttribute = baseLog.ContactFlowModuleType === 'CheckAttribute';

      // CheckAttribute의 경우 Parameters에 Results 키를 추가하고 enrichment 데이터 보존
      if (isCheckAttribute) {
        baseLog.Parameters = group.map(log => ({
          ...log.Parameters,
          Results: log.Results,
          _comparisonValue: log.Parameters?._comparisonValue,
          _comparisonSecondValue: log.Parameters?._comparisonSecondValue,
        }));
      } else {
        // SetAttributes, SetFlowAttributes의 경우 Parameters만 배열로 저장
        baseLog.Parameters = group.map(log => log.Parameters);
      }

      const anyError = group.some(log =>
        log.Results?.includes('Error') ||
        log.Results?.includes('Failed') ||
        log.ExternalResults?.isSuccess === 'false'
      );

      if (anyError) {
        (baseLog as any)._isGroupError = true;
        baseLog.Results = group[group.length - 1].Results || "Error in group";
      } else {
        baseLog.Results = group[group.length - 1].Results;
      }

      baseLog.Timestamp = group[group.length - 1].Timestamp;
      consolidated.push(baseLog);
    }
    group = [];
    currentGroupType = null;
  };

  const mergeGetUserInputGroup = () => {
    if (getUserInputGroup.length === 0) return;

    if (getUserInputGroup.length === 1) {
      consolidated.push(getUserInputGroup[0]);
    } else {
      // GetUserInput 로그 병합: 첫 번째 로그의 Parameters를 사용하고, 마지막 로그의 Results를 footer로 표시
      const baseLog = { ...getUserInputGroup[0] };

      // 마지막 로그의 Results 사용 (사용자 입력 결과)
      const finalResults = getUserInputGroup[getUserInputGroup.length - 1].Results;
      baseLog.Results = finalResults;
      baseLog.Timestamp = getUserInputGroup[getUserInputGroup.length - 1].Timestamp;

      // Footer에 표시할 Results를 별도 필드로 저장
      (baseLog as any)._footerResults = finalResults;

      consolidated.push(baseLog);
    }
    getUserInputGroup = [];
    currentGetUserInputIdentifier = null;
  };

  const mergeInvokeExternalGroup = () => {
    if (invokeExternalGroup.length === 0) return;

    if (invokeExternalGroup.length === 1) {
      consolidated.push(invokeExternalGroup[0]);
    } else {
      // InvokeExternalResource 로그 병합: 첫 번째 로그의 Parameters를 사용하고, 마지막 로그의 ExternalResults를 footer로 표시
      const baseLog = { ...invokeExternalGroup[0] };

      // 마지막 로그의 ExternalResults 사용
      const finalExternalResults = invokeExternalGroup[invokeExternalGroup.length - 1].ExternalResults;
      baseLog.ExternalResults = finalExternalResults;
      baseLog.Timestamp = invokeExternalGroup[invokeExternalGroup.length - 1].Timestamp;

      // Footer에 표시할 ExternalResults를 별도 필드로 저장
      (baseLog as any)._footerExternalResults = finalExternalResults;

      consolidated.push(baseLog);
    }
    invokeExternalGroup = [];
    currentInvokeExternalIdentifier = null;
  };

  for (const log of logs) {
    if (['GetUserInput','PlayPrompt','StoreUserInput'].includes(log.ContactFlowModuleType)) {
      // GetUserInput 로그 처리: 같은 Identifier를 가진 연속된 로그를 병합
      const identifier = log.Identifier;

      // Identifier가 다르면 이전 그룹을 먼저 병합
      if (currentGetUserInputIdentifier !== null && currentGetUserInputIdentifier !== identifier) {
        mergeGetUserInputGroup();
      }

      // 이전에 다른 그룹이 있었다면 먼저 병합
      mergeGroup();
      mergeInvokeExternalGroup();

      currentGetUserInputIdentifier = identifier || null;
      getUserInputGroup.push(log);
    } else if (['InvokeExternalResource', 'InvokeLambdaFunction'].includes(log.ContactFlowModuleType)) {
      // InvokeExternalResource 로그 처리: 같은 Identifier를 가진 연속된 로그를 병합
      const identifier = log.Identifier;

      // Identifier가 다르면 이전 그룹을 먼저 병합
      if (currentInvokeExternalIdentifier !== null && currentInvokeExternalIdentifier !== identifier) {
        mergeInvokeExternalGroup();
      }

      // 이전에 다른 그룹이 있었다면 먼저 병합
      mergeGroup();
      mergeGetUserInputGroup();

      currentInvokeExternalIdentifier = identifier || null;
      invokeExternalGroup.push(log);
    } else if (['SetAttributes', 'SetFlowAttributes', 'CheckAttribute'].includes(log.ContactFlowModuleType)) {
      const logType = log.ContactFlowModuleType;

      // 다른 그룹이 있었다면 먼저 병합
      mergeGetUserInputGroup();
      mergeInvokeExternalGroup();

      // 타입이 다르면 이전 그룹을 먼저 병합
      if (currentGroupType !== null && currentGroupType !== logType) {
        mergeGroup();
      }

      currentGroupType = logType;
      group.push(log);
    } else {
      mergeGroup();
      mergeGetUserInputGroup();
      mergeInvokeExternalGroup();
      consolidated.push(log);
    }
  }

  mergeGroup();
  mergeGetUserInputGroup();
  mergeInvokeExternalGroup();
  return consolidated;
};

const ModuleDetailViewer: React.FC = () => {
  const { contactId, flowName, moduleName } = useParams<{ contactId: string; flowName: string; moduleName: string }>();
  const navigate = useNavigate();
  const location = useLocation();
  const state = location.state as LocationState;
  const { config } = useConfig();

  const [nodes, setNodes, onNodesChange] = useNodesState<ReactFlowNode[]>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  const [originalLogs, setOriginalLogs] = useState<ContactLog[]>([]);
  const [processedLogs, setProcessedLogs] = useState<ContactLog[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const [selectedLog, setSelectedLog] = useState<ContactLog | null>(null);
  const [isTimelineVisible, setIsTimelineVisible] = useState(false);
  const detailsPanelRef = React.useRef<HTMLDivElement>(null);
  const [searchTerm, setSearchTerm] = useState('');

  // Effect to handle Esc key and click outside to close details panel
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setIsTimelineVisible(false);
      }
    };

    const handleClickOutside = (event: MouseEvent) => {
      if (detailsPanelRef.current && !detailsPanelRef.current.contains(event.target as Node)) {
        setIsTimelineVisible(false);
      }
    };

    if (isTimelineVisible) {
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isTimelineVisible]);

  // Initialize logs from location state
  useEffect(() => {
    const processLogs = async () => {
      if (state?.chunkedLogs && config) {
        setIsLoading(true);
        try {
          setOriginalLogs(state.chunkedLogs);

          // 1. CheckAttribute 로그에 flow definition 데이터 추가
          const enrichedLogs = await enrichCheckAttributeLogs(state.chunkedLogs, config);

          // 2. SetAttributes 병합
          const consolidated = consolidateSetAttributesLogs(enrichedLogs);
          setProcessedLogs(consolidated);

          buildFlowVisualization(consolidated);
        } catch (error) {
          console.error('Error processing logs:', error);
          // 에러 발생 시 enrichment 없이 진행
          const consolidated = consolidateSetAttributesLogs(state.chunkedLogs);
          setProcessedLogs(consolidated);
          buildFlowVisualization(consolidated);
        } finally {
          setIsLoading(false);
        }
      }
    };

    processLogs();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state, config]);

  // Build flow visualization from chunked logs with "ㄹ" pattern layout
  const buildFlowVisualization = (logsToProcess: ContactLog[]) => {
    const flowNodes: ReactFlowNode[] = [];
    const flowEdges: Edge[] = [];

    // Grid layout configuration
    const columns = 5;
    const nodeWidth = 280;
    const nodeHeight = 180;
    const horizontalGap = 40;
    const verticalGap = 80;

    logsToProcess.forEach((log, index) => {
      const hasError =
        (log as any)._isGroupError ||
        log.Results?.includes('Error') ||
        log.Results?.includes('Failed') ||
        log.ExternalResults?.isSuccess === 'false';

      const row = Math.floor(index / columns);
      const isEvenRow = row % 2 === 0;
      let column: number;
      if (isEvenRow) {
        column = index % columns;
      } else {
        column = columns - 1 - (index % columns);
      }
      const x = column * (nodeWidth + horizontalGap);
      const y = row * (nodeHeight + verticalGap);

      const hasNextNode = index < logsToProcess.length - 1;
      const isLastInRow = (index + 1) % columns === 0;
      const isFirstInRow = index % columns === 0;
      let sourcePosition: Position | undefined = undefined;
      let targetPosition: Position | undefined = undefined;

      if (hasNextNode) {
        if (isLastInRow) {
          sourcePosition = Position.Bottom;
        } else {
          sourcePosition = isEvenRow ? Position.Right : Position.Left;
        }
      }
      if (index === 0) {
        targetPosition = Position.Left;
      } else if (isFirstInRow && row > 0) {
        targetPosition = Position.Top;
      } else {
        targetPosition = isEvenRow ? Position.Left : Position.Right;
      }

      const node: ReactFlowNode = {
        id: `${log.Timestamp}_${index}`,
        type: 'custom',
        position: { x, y },
        data: {
          label: log.ContactFlowModuleType,
          moduleType: log.ContactFlowModuleType,
          parameters: log.Parameters,
          results: log.Results,
          externalResults: log.ExternalResults, // ExternalResults 추가
          error: hasError,
          timestamp: log.Timestamp,
          sourcePosition,
          targetPosition,
          logData: log, // footer를 위해 필요
          isMainView: false, // Module Detail View임을 CustomNode에 전달
        },
        style: {
          background: hasError ? '#FFEBEE' : '#F5F5F5',
          border: hasError ? '2px solid #F44336' : '1px solid #E0E0E0',
          borderRadius: '8px',
          padding: '10px',
          width: nodeWidth,
        },
      };

      flowNodes.push(node);

      if (index > 0) {
        const prevLog = logsToProcess[index - 1];
        const prevNode = flowNodes[index - 1];

        const getHandleId = (pos: Position | undefined): string | undefined => {
          if (!pos) return undefined;
          const posMap: Record<Position, string> = {
            [Position.Top]: 'top', [Position.Bottom]: 'bottom', [Position.Left]: 'left', [Position.Right]: 'right',
          };
          return posMap[pos];
        };

        const sourceHandleId = prevNode.data.sourcePosition ? `source-${getHandleId(prevNode.data.sourcePosition)}` : undefined;
        const targetHandleId = targetPosition ? `target-${getHandleId(targetPosition)}` : undefined;

        flowEdges.push({
          id: `edge_${index - 1}_${index}`,
          source: `${prevLog.Timestamp}_${index - 1}`,
          target: `${log.Timestamp}_${index}`,
          sourceHandle: sourceHandleId,
          targetHandle: targetHandleId,
          type: 'smoothstep',
          animated: false,
          markerEnd: { type: MarkerType.ArrowClosed },
          style: { stroke: hasError ? '#F44336' : '#B0B0B0', strokeWidth: 2 },
        });
      }
    });

    setNodes(flowNodes);
    setEdges(flowEdges);
  };

  // Handle node click
  const onNodeClick = useCallback((event: React.MouseEvent, node: ReactFlowNode) => {
    if (node.data?.logData) {
      setSelectedLog(node.data.logData);
      setIsTimelineVisible(true);
    }
  }, []);

  // Handle export
  const handleExport = () => {
    const dataStr = JSON.stringify({ moduleName: state?.moduleName, logs: originalLogs }, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
    const exportFileDefaultName = `module-detail-${moduleName}.json`;

    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
  };

  // Handle search
  const handleSearch = (term: string) => {
    setSearchTerm(term);

    if (term) {
      const filteredNodes = nodes.map((node: ReactFlowNode) => {
        const lowerTerm = term.toLowerCase();
        const label = node.data?.label || '';
        const parameters = node.data?.parameters || {};
        const identifier = node.data?.logData?.Identifier || '';

        const matches =
          label.toLowerCase().includes(lowerTerm) ||
          identifier.toLowerCase().includes(lowerTerm) ||
          JSON.stringify(parameters).toLowerCase().includes(lowerTerm);

        return {
          ...node,
          style: {
            ...node.style,
            opacity: matches ? 1 : 0.3,
          },
        };
      });

      setNodes(filteredNodes);
    } else {
      // Reset opacity
      const resetNodes = nodes.map((node: ReactFlowNode) => ({
        ...node,
        style: {
          ...node.style,
          opacity: 1,
        },
      }));

      setNodes(resetNodes);
    }
  };

  const renderValue = (value: any) => {
    if (typeof value === 'object' && value !== null) {
      return (
        <pre style={{ fontSize: '0.75rem', whiteSpace: 'pre-wrap', wordBreak: 'break-all', margin: 0 }}>
          {JSON.stringify(value, null, 2)}
        </pre>
      );
    }
    return String(value);
  };

  if (!state?.chunkedLogs) {
    return (
      <Container sx={{ mt: 4 }}>
        <Alert severity="warning" sx={{ mb: 2 }}>
          No module data available. Please navigate from the flow detail view.
        </Alert>
        <Button
          variant="outlined"
          onClick={() => navigate(`/contact-flow/${contactId}/flow/${encodeURIComponent(flowName || '')}`)}
          startIcon={<BackIcon />}
        >
          Back to Flow Detail
        </Button>
      </Container>
    );
  }

  const errorCount = originalLogs.filter(log =>
    log.Results?.includes('Error') ||
    log.Results?.includes('Failed') ||
    log.ExternalResults?.isSuccess === 'false'
  ).length;

  const timeRangeText = originalLogs.length > 0
    ? `${new Date(originalLogs[0].Timestamp).toLocaleTimeString()} - ${new Date(originalLogs[originalLogs.length - 1].Timestamp).toLocaleTimeString()}`
    : 'N/A';

  return (
    <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* Header - Fixed */}
      <Box sx={{ position: 'sticky', top: 0, zIndex: 1000, backgroundColor: 'background.paper' }}>
        {/* Toolbar */}
        <Paper elevation={1} sx={{ zIndex: 10 }}>
          <Toolbar>
            <IconButton edge="start" onClick={() => navigate(-1)}>
              <BackIcon />
            </IconButton>
            <Typography variant="h6" sx={{ flexGrow: 1, ml: 2 }}>
              Module Detail: {state?.moduleName || moduleName || 'Unknown'}
            </Typography>

            {/* Search */}
            <TextField
              size="small"
              placeholder="Search nodes..."
              value={searchTerm}
              onChange={(e) => handleSearch(e.target.value)}
              sx={{ mr: 2, width: 250 }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />

            <Stack direction="row" spacing={1}>
              <Tooltip title="Export JSON">
                <IconButton onClick={handleExport}>
                  <DownloadIcon />
                </IconButton>
              </Tooltip>
              {/* <Tooltip title={isTimelineVisible ? "Hide Details" : "Show Details"}>
                <IconButton onClick={() => setIsTimelineVisible(!isTimelineVisible)}>
                  <VerticalSplitIcon />
                </IconButton>
              </Tooltip> */}
            </Stack>
          </Toolbar>
        </Paper>

        {/* Module Statistics */}
        <Paper elevation={0} sx={{ p: 1, borderBottom: 1, borderColor: 'divider' }}>
          <Stack direction="row" spacing={2} alignItems="center">
            <Chip
              label={`Total Logs: ${originalLogs.length}`}
              size="small"
              color="primary"
              variant="outlined"
            />
            <Chip
              label={`Time Range: ${timeRangeText}`}
              size="small"
              color="secondary"
              variant="outlined"
            />
            <Chip
              icon={errorCount > 0 ? <ErrorIcon /> : <SuccessIcon />}
              label={`Errors: ${errorCount}`}
              size="small"
              color={errorCount > 0 ? 'error' : 'default'}
              variant="outlined"
            />
          </Stack>
        </Paper>
      </Box>

      {/* Main Content: Split View */}
      <Box sx={{ flex: 1, display: 'flex', flexDirection: 'row', overflow: 'hidden' }}>
        {/* Left: Flow Visualization */}
        <Box sx={{ flex: 1, minWidth: 0 }}>
          <ReactFlowProvider>
            <ReactFlow
              nodes={nodes}
              edges={edges}
              onNodesChange={onNodesChange}
              onEdgesChange={onEdgesChange}
              onNodeClick={onNodeClick}
              nodeTypes={nodeTypes}
              fitView
              attributionPosition="bottom-left"
            >
              <Background gap={12} size={1} />
              <Controls />
              <MiniMap
                nodeStrokeColor={(n) => (n.data?.error ? '#f44336' : '#888')}
                nodeColor={(n) => (n.data?.error ? '#ffebee' : '#f5f5f5')}
                nodeBorderRadius={4}
              />
            </ReactFlow>
          </ReactFlowProvider>
        </Box>

        {/* Right: Log Details Panel */}
        {isTimelineVisible && selectedLog && (
          <Box
            ref={detailsPanelRef}
            sx={{
              width: 450,
              borderLeft: 1,
              borderColor: 'divider',
              overflowY: 'auto',
              bgcolor: 'background.paper',
            }}
          >
            <Box sx={{ p: 2 }}>
              <Typography variant="h6" gutterBottom>
                Log Details
              </Typography>
              <Divider sx={{ mb: 2 }} />

              {(() => {
                const hasError =
                  (selectedLog as any)._isGroupError ||
                  selectedLog.Results?.includes('Error') ||
                  selectedLog.Results?.includes('Failed') ||
                  selectedLog.ExternalResults?.isSuccess === 'false';

                return (
                  <Card
                    variant="outlined"
                    sx={{
                      borderLeft: `4px solid ${hasError ? '#F44336' : '#2196F3'}`,
                    }}
                  >
                    <CardContent>
                      <Stack direction="row" spacing={1} alignItems="center" sx={{ mb: 2 }}>
                        {hasError ? (
                          <ErrorIcon fontSize="small" color="error" />
                        ) : (
                          <SuccessIcon fontSize="small" color="success" />
                        )}
                        <Typography variant="h6" fontWeight="bold">
                          {selectedLog.ContactFlowModuleType}
                        </Typography>
                      </Stack>

                      <Stack direction="row" spacing={1} alignItems="center" sx={{ mb: 1 }}>
                        <TimeIcon fontSize="small" color="disabled" />
                        <Typography variant="body2" color="text.secondary">
                          {new Date(selectedLog.Timestamp).toLocaleString()}
                        </Typography>
                      </Stack>

                      {selectedLog.Identifier && (
                        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                          <strong>ID:</strong> {selectedLog.Identifier}
                        </Typography>
                      )}

                      {selectedLog.Results && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="body2" fontWeight="bold" sx={{ mb: 0.5 }}>
                            Results:
                          </Typography>
                          <Chip
                            label={selectedLog.Results}
                            size="small"
                            color={hasError ? 'error' : 'success'}
                          />
                        </Box>
                      )}

                      <Divider sx={{ my: 2 }} />

                      {selectedLog.Parameters && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="body2" fontWeight="bold" sx={{ mb: 1 }}>
                            Parameters:
                          </Typography>
                          <Box sx={{
                            bgcolor: '#F5F5F5',
                            p: 1.5,
                            borderRadius: 1,
                            maxHeight: '400px',
                            overflowY: 'auto'
                          }}>
                            {renderValue(selectedLog.Parameters)}
                          </Box>
                        </Box>
                      )}

                      {selectedLog.ExternalResults && (
                        <Box>
                          <Typography variant="body2" fontWeight="bold" sx={{ mb: 1 }}>
                            External Results:
                          </Typography>
                          <Box sx={{
                            bgcolor: '#F5F5F5',
                            p: 1.5,
                            borderRadius: 1,
                            maxHeight: '400px',
                            overflowY: 'auto'
                          }}>
                            {renderValue(selectedLog.ExternalResults)}
                          </Box>
                        </Box>
                      )}
                    </CardContent>
                  </Card>
                );
              })()}
            </Box>
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default ModuleDetailViewer;


---------------------
/Users/ke-aicc/Downloads/files/src/pages/FlowDetailViewer.tsx
---------------------
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import {
  Container,
  Paper,
  Box,
  Typography,
  Button,
  CircularProgress,
  Alert,
  Toolbar,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Chip,
  Stack,
  Divider,
  TextField,
  InputAdornment,
} from '@mui/material';
import {
  ArrowBack as BackIcon,
  Download as DownloadIcon,
  CheckCircle as SuccessIcon,
  Error as ErrorIcon,
  AccessTime as TimeIcon,
  VerticalSplit as VerticalSplitIcon,
  Search as SearchIcon,
} from '@mui/icons-material';
import ReactFlow, {
  Node as ReactFlowNode,
  Edge,
  Controls,
  Background,
  MiniMap,
  useNodesState,
  useEdgesState,
  MarkerType,
  ReactFlowProvider,
  Position,
} from 'react-flow-renderer';
import { ContactLog } from '@/types/contact.types';
import { processLogsForDetailView, enrichCheckAttributeLogs } from '@/utils/logProcessor';
import CustomNode from '@/components/FlowNodes/CustomNode';
import { useConfig } from '@/contexts/ConfigContext';

const nodeTypes = {
  custom: (props: any) => <CustomNode {...props} isMainView={false} />,
};

interface LocationState {
  chunkedLogs?: ContactLog[];
  flowName?: string;
  contactId?: string;
}

const FlowDetailViewer: React.FC = () => {
  const { contactId, flowName } = useParams<{ contactId: string; flowName: string }>();
  const navigate = useNavigate();
  const location = useLocation();
  const state = location.state as LocationState;
  const { config } = useConfig();

  const [nodes, setNodes, onNodesChange] = useNodesState<ReactFlowNode[]>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  const [originalLogs, setOriginalLogs] = useState<ContactLog[]>([]);
  const [processedLogs, setProcessedLogs] = useState<ContactLog[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const [selectedLog, setSelectedLog] = useState<ContactLog | null>(null);
  const [isTimelineVisible, setIsTimelineVisible] = useState(false);
  const detailsPanelRef = React.useRef<HTMLDivElement>(null);
  const [searchTerm, setSearchTerm] = useState('');

  // Effect to handle Esc key and click outside to close details panel
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setIsTimelineVisible(false);
      }
    };

    const handleClickOutside = (event: MouseEvent) => {
      if (detailsPanelRef.current && !detailsPanelRef.current.contains(event.target as Node)) {
        setIsTimelineVisible(false);
      }
    };

    if (isTimelineVisible) {
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isTimelineVisible]);

  useEffect(() => {
    const processLogs = async () => {
      if (state?.chunkedLogs && config) {
        setIsLoading(true);
        try {
          setOriginalLogs(state.chunkedLogs);

          // 1. CheckAttribute 로그에 flow definition 데이터 추가
          const enrichedLogs = await enrichCheckAttributeLogs(state.chunkedLogs, config);

          // 2. 통합된 로그 처리 함수 사용 (병합)
          const consolidated = processLogsForDetailView(enrichedLogs);
          setProcessedLogs(consolidated);

          buildFlowVisualization(consolidated);
        } catch (error) {
          console.error('Error processing logs:', error);
          // 에러 발생 시 enrichment 없이 진행
          const consolidated = processLogsForDetailView(state.chunkedLogs);
          setProcessedLogs(consolidated);
          buildFlowVisualization(consolidated);
        } finally {
          setIsLoading(false);
        }
      }
    };

    processLogs();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state, config]);

  // Build flow visualization from chunked logs with "ㄹ" pattern layout
  const buildFlowVisualization = (logsToProcess: ContactLog[]) => {
    // 이제 이 함수는 '병합된' 로그 리스트(logsToProcess)를 받습니다.
    const flowNodes: ReactFlowNode[] = [];
    const flowEdges: Edge[] = [];

    // Grid layout configuration
    const columns = 5;
    const nodeWidth = 280;
    const nodeHeight = 180;
    const horizontalGap = 40;
    const verticalGap = 80;

    logsToProcess.forEach((log, index) => {
      // 모듈 노드 확인
      const isModuleNode = (log as any)._isModuleNode;
      const moduleName = (log as any)._moduleName;
      const moduleLogs = (log as any)._moduleLogs;

      // (수정) 병합된 에러 플래그 확인
      const hasError =
        (log as any)._hasError ||
        (log as any)._isGroupError ||
        log.Results?.includes('Error') ||
        log.Results?.includes('Failed') ||
        log.ExternalResults?.isSuccess === 'false';

      // ... (x, y 좌표 계산 로직은 동일) ...
      const row = Math.floor(index / columns);
      const isEvenRow = row % 2 === 0;
      let column: number;
      if (isEvenRow) {
        column = index % columns;
      } else {
        column = columns - 1 - (index % columns);
      }
      const x = column * (nodeWidth + horizontalGap);
      const y = row * (nodeHeight + verticalGap);

      // ... (Handle Posiion 계산 로직은 동일) ...
      const hasNextNode = index < logsToProcess.length - 1;
      const isLastInRow = (index + 1) % columns === 0;
      const isFirstInRow = index % columns === 0;
      let sourcePosition: Position | undefined = undefined;
      let targetPosition: Position | undefined = undefined;

      if (hasNextNode) {
        if (isLastInRow) {
          sourcePosition = Position.Bottom;
        } else {
          sourcePosition = isEvenRow ? Position.Right : Position.Left;
        }
      }
      if (index === 0) {
        targetPosition = Position.Left;
      } else if (isFirstInRow && row > 0) {
        targetPosition = Position.Top;
      } else {
        targetPosition = isEvenRow ? Position.Left : Position.Right;
      }

      const node: ReactFlowNode = {
        id: `${log.Timestamp}_${index}`,
        type: 'custom',
        position: { x, y },
        data: {
          label: isModuleNode ? moduleName : log.ContactFlowModuleType,
          moduleType: isModuleNode ? 'FlowModule' : log.ContactFlowModuleType,
          parameters: log.Parameters,
          results: log.Results,
          externalResults: log.ExternalResults, // ExternalResults 추가
          error: hasError,
          timestamp: log.Timestamp,
          sourcePosition,
          targetPosition,
          logData: log, // 노드 클릭 시 사용할 병합된 로그 데이터 (footer를 위해 필요)
          isModuleNode, // 모듈 노드 플래그
          moduleLogs, // 모듈 내부 로그들
          timeRange: (log as any)._timeRange, // 모듈 시간 범위
          logCount: (log as any)._logCount, // 모듈 로그 개수
          isMainView: false, // Detail View임을 CustomNode에 전달
        },
        style: {
          background: hasError ? '#FFEBEE' : isModuleNode ? '#E3F2FD' : '#F5F5F5',
          border: hasError ? '2px solid #F44336' : isModuleNode ? '2px solid #2196F3' : '1px solid #E0E0E0',
          borderRadius: '8px',
          padding: '10px',
          width: nodeWidth,
        },
      };

      flowNodes.push(node);

      // ... (Edge 생성 로직은 동일) ...
      if (index > 0) {
        const prevLog = logsToProcess[index - 1];
        const prevNode = flowNodes[index - 1];

        const getHandleId = (pos: Position | undefined): string | undefined => {
          if (!pos) return undefined;
          const posMap: Record<Position, string> = {
            [Position.Top]: 'top', [Position.Bottom]: 'bottom', [Position.Left]: 'left', [Position.Right]: 'right',
          };
          return posMap[pos];
        };

        const sourceHandleId = prevNode.data.sourcePosition ? `source-${getHandleId(prevNode.data.sourcePosition)}` : undefined;
        const targetHandleId = targetPosition ? `target-${getHandleId(targetPosition)}` : undefined;

        flowEdges.push({
          id: `edge_${index - 1}_${index}`,
          source: `${prevLog.Timestamp}_${index - 1}`, // prevLog 사용
          target: `${log.Timestamp}_${index}`,
          sourceHandle: sourceHandleId,
          targetHandle: targetHandleId,
          type: 'smoothstep',
          animated: false,
          markerEnd: { type: MarkerType.ArrowClosed },
          style: { stroke: hasError ? '#F44336' : '#B0B0B0', strokeWidth: 2 },
        });
      }
    });

    setNodes(flowNodes);
    setEdges(flowEdges);
  };

  // Handle node click
  const onNodeClick = useCallback((event: React.MouseEvent, node: ReactFlowNode) => {
    if (node.data?.isModuleNode && node.data?.moduleLogs) {
      // 모듈 노드 클릭 시 ModuleDetailViewer로 이동
      const moduleName = node.data.label;
      const currentFlowName = state?.flowName || flowName;
      navigate(`/contact-flow/${contactId}/flow/${encodeURIComponent(currentFlowName || '')}/module/${encodeURIComponent(moduleName)}`, {
        state: {
          chunkedLogs: node.data.moduleLogs,
          moduleName,
          contactId,
          flowName: currentFlowName,
        },
      });
    } else if (node.data?.logData) {
      setSelectedLog(node.data.logData); // 병합된 로그를 선택
      setIsTimelineVisible(true); // 노드 클릭 시 타임라인 자동으로 열기
    }
  }, [contactId, flowName, navigate, state?.flowName]); 

  // Handle export
  const handleExport = () => {
    // 내보내기는 '원본' 로그를 사용
    const dataStr = JSON.stringify({ flowName: state?.flowName, logs: originalLogs }, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
    const exportFileDefaultName = `flow-detail-${flowName}.json`;

    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
  };

  // Handle search with deep search support
  const handleSearch = (term: string) => {
    setSearchTerm(term);

    if (term) {
      const filteredNodes = nodes.map((node: ReactFlowNode) => {
        const lowerTerm = term.toLowerCase();
        const label = node.data?.label || '';
        const parameters = node.data?.parameters || {};
        const identifier = node.data?.logData?.Identifier || '';
        const isModuleNode = node.data?.isModuleNode || false;
        const moduleLogs = node.data?.moduleLogs || [];

        // Basic search (current node)
        let matches =
          label.toLowerCase().includes(lowerTerm) ||
          identifier.toLowerCase().includes(lowerTerm) ||
          JSON.stringify(parameters).toLowerCase().includes(lowerTerm);

        // Deep search (for module nodes, search in child logs)
        if (!matches && isModuleNode && moduleLogs.length > 0) {
          matches = moduleLogs.some((log: ContactLog) => {
            const logLabel = log.ContactFlowModuleType || '';
            const logParams = log.Parameters || {};
            const logId = log.Identifier || '';
            const logResults = log.Results || '';
            const logExternalResults = log.ExternalResults || {};

            return (
              logLabel.toLowerCase().includes(lowerTerm) ||
              logId.toLowerCase().includes(lowerTerm) ||
              logResults.toLowerCase().includes(lowerTerm) ||
              JSON.stringify(logParams).toLowerCase().includes(lowerTerm) ||
              JSON.stringify(logExternalResults).toLowerCase().includes(lowerTerm)
            );
          });
        }

        return {
          ...node,
          style: {
            ...node.style,
            opacity: matches ? 1 : 0.3,
          },
        };
      });

      setNodes(filteredNodes);
    } else {
      // Reset opacity
      const resetNodes = nodes.map((node: ReactFlowNode) => ({
        ...node,
        style: {
          ...node.style,
          opacity: 1,
        },
      }));

      setNodes(resetNodes);
    }
  };

  const renderValue = (value: any) => {
    // 이 함수는 Parameters가 배열이든 객체이든 알아서 잘 처리합니다.
    if (typeof value === 'object' && value !== null) {
      return (
        <pre style={{ fontSize: '0.75rem', whiteSpace: 'pre-wrap', wordBreak: 'break-all', margin: 0 }}>
          {JSON.stringify(value, null, 2)}
        </pre>
      );
    }
    return String(value);
  };

  if (!state?.chunkedLogs) {
    // ... (No data Alert) ...
    return (
      <Container sx={{ mt: 4 }}>
        <Alert severity="warning" sx={{ mb: 2 }}>
          No flow data available. Please navigate from the main contact flow view.
        </Alert>
        <Button
          variant="outlined"
          onClick={() => navigate(`/contact-flow/${contactId}`)}
          startIcon={<BackIcon />}
        >
          Back to Contact Flow
        </Button>
      </Container>
    );
  }

  // 통계는 '원본' 로그 기준
  const errorCount = originalLogs.filter(log =>
    log.Results?.includes('Error') ||
    log.Results?.includes('Failed') ||
    log.ExternalResults?.isSuccess === 'false'
  ).length;

  const timeRangeText = originalLogs.length > 0
    ? `${new Date(originalLogs[0].Timestamp).toLocaleTimeString()} - ${new Date(originalLogs[originalLogs.length - 1].Timestamp).toLocaleTimeString()}`
    : 'N/A';

  return (
    <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* Header - Fixed */}
      <Box sx={{ position: 'sticky', top: 0, zIndex: 1000, backgroundColor: 'background.paper' }}>
        {/* Toolbar */}
        <Paper elevation={1} sx={{ zIndex: 10 }}>
          <Toolbar>
            <IconButton edge="start" onClick={() => navigate(-1)}>
              <BackIcon />
            </IconButton>
            <Typography variant="h6" sx={{ flexGrow: 1, ml: 2 }}>
              Flow Detail: {state?.flowName || flowName || 'Unknown'}
            </Typography>

            {/* Search */}
            <TextField
              size="small"
              placeholder="Search nodes..."
              value={searchTerm}
              onChange={(e) => handleSearch(e.target.value)}
              sx={{ mr: 2, width: 250 }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />

            <Stack direction="row" spacing={1}>
              <Tooltip title="Export JSON">
                <IconButton onClick={handleExport}>
                  <DownloadIcon />
                </IconButton>
              </Tooltip>
              {/* <Tooltip title={isTimelineVisible ? "Hide Details" : "Show Details"}>
                <IconButton onClick={() => setIsTimelineVisible(!isTimelineVisible)}>
                  <VerticalSplitIcon />
                </IconButton>
              </Tooltip> */}
            </Stack>
          </Toolbar>
        </Paper>

        {/* Flow Statistics (원본 로그 기준) */}
        <Paper elevation={0} sx={{ p: 1, borderBottom: 1, borderColor: 'divider' }}>
          <Stack direction="row" spacing={2} alignItems="center">
            <Chip
              label={`Total Logs: ${originalLogs.length}`}
              size="small"
              color="primary"
              variant="outlined"
            />
            <Chip
              label={`Time Range: ${timeRangeText}`}
              size="small"
              color="secondary"
              variant="outlined"
            />
            <Chip
              label={`Errors: ${errorCount}`}
              size="small"
              color={errorCount > 0 ? 'error' : 'default'}
              variant="outlined"
            />
          </Stack>
        </Paper>
      </Box>

      {/* Main Content: Split View */}
      <Box sx={{ flex: 1, display: 'flex', flexDirection: 'row', overflow: 'hidden' }}>
        {/* Left: Flow Visualization (병합된 노드) */}
        <Box sx={{ flex: 1, minWidth: 0 }}>
          <ReactFlowProvider>
            <ReactFlow
              nodes={nodes}
              edges={edges}
              onNodesChange={onNodesChange}
              onEdgesChange={onEdgesChange}
              onNodeClick={onNodeClick}
              nodeTypes={nodeTypes}
              fitView
              attributionPosition="bottom-left"
              preventScrolling={false}
              // zoomOnScroll={false}
              // panOnScroll={false}
            >
              <Background gap={12} size={1} />
              <Controls />
              <MiniMap
                nodeStrokeColor={(n) => (n.data?.error ? '#f44336' : '#888')}
                nodeColor={(n) => (n.data?.error ? '#ffebee' : '#f5f5f5')}
                nodeBorderRadius={4}
              />
            </ReactFlow>
          </ReactFlowProvider>
        </Box>

        {/* --- (수정) Right: Log Details Panel (선택된 노드만 표시) --- */}
        {isTimelineVisible && selectedLog && (
          <Box
            ref={detailsPanelRef}
            sx={{
              width: 450,
              borderLeft: 1,
              borderColor: 'divider',
              overflowY: 'auto',
              bgcolor: 'background.paper',
            }}
          >
            <Box sx={{ p: 2 }}>
              <Typography variant="h6" gutterBottom>
                Log Details
              </Typography>
              <Divider sx={{ mb: 2 }} />

              {(() => {
                const hasError =
                  (selectedLog as any)._isGroupError ||
                  selectedLog.Results?.includes('Error') ||
                  selectedLog.Results?.includes('Failed') ||
                  selectedLog.ExternalResults?.isSuccess === 'false';

                return (
                  <Card
                    variant="outlined"
                    sx={{
                      borderLeft: `4px solid ${hasError ? '#F44336' : '#2196F3'}`,
                    }}
                  >
                    <CardContent>
                      <Stack direction="row" spacing={1} alignItems="center" sx={{ mb: 2 }}>
                        {hasError ? (
                          <ErrorIcon fontSize="small" color="error" />
                        ) : (
                          <SuccessIcon fontSize="small" color="success" />
                        )}
                        <Typography variant="h6" fontWeight="bold">
                          {selectedLog.ContactFlowModuleType}
                        </Typography>
                      </Stack>

                      <Stack direction="row" spacing={1} alignItems="center" sx={{ mb: 1 }}>
                        <TimeIcon fontSize="small" color="disabled" />
                        <Typography variant="body2" color="text.secondary">
                          {new Date(selectedLog.Timestamp).toLocaleString()}
                        </Typography>
                      </Stack>

                      {selectedLog.Identifier && (
                        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                          <strong>ID:</strong> {selectedLog.Identifier}
                        </Typography>
                      )}

                      {selectedLog.Results && selectedLog.ContactFlowModuleType !== "CheckAttribute" && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="body2" fontWeight="bold" sx={{ mb: 0.5 }}>
                            Results:
                          </Typography>
                          <Chip
                            label={selectedLog.Results}
                            size="small"
                            color={hasError ? 'error' : 'success'}
                          />
                        </Box>
                      )}

                      <Divider sx={{ my: 2 }} />

                      {selectedLog.Parameters && (
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="body2" fontWeight="bold" sx={{ mb: 1 }}>
                            Parameters:
                          </Typography>
                          <Box sx={{
                            bgcolor: '#F5F5F5',
                            p: 1.5,
                            borderRadius: 1,
                            maxHeight: '400px',
                            overflowY: 'auto'
                          }}>
                            {renderValue(selectedLog.Parameters)}
                          </Box>
                        </Box>
                      )}

                      {selectedLog.ExternalResults && (
                        <Box>
                          <Typography variant="body2" fontWeight="bold" sx={{ mb: 1 }}>
                            External Results:
                          </Typography>
                          <Box sx={{
                            bgcolor: '#F5F5F5',
                            p: 1.5,
                            borderRadius: 1,
                            maxHeight: '400px',
                            overflowY: 'auto'
                          }}>
                            {renderValue(selectedLog.ExternalResults)}
                          </Box>
                        </Box>
                      )}
                    </CardContent>
                  </Card>
                );
              })()}
            </Box>
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default FlowDetailViewer;

---------------------
/Users/ke-aicc/Downloads/files/src/pages/LogAnalysis.tsx
---------------------
import React from 'react';
import { Box, Typography } from '@mui/material';

const LogAnalysis: React.FC = () => {
  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        Log Analysis
      </Typography>
      <Typography>
        Log analysis functionality coming soon...
      </Typography>
    </Box>
  );
};

export default LogAnalysis;


---------------------
/Users/ke-aicc/Downloads/files/src/services/flowDefinitionService.ts
---------------------
/**
 * Flow Definition Service
 *
 * AWS Connect의 Contact Flow 및 Flow Module 정의를 조회하고 파싱하는 서비스
 * describe_contact_flow 및 describe_contact_flow_module API를 사용하여
 * flow definition JSON을 가져오고, 이를 통해 CheckAttribute 등의 블록에 대한
 * 비교값 메타데이터를 추출합니다.
 */

import {
  ConnectClient,
  DescribeContactFlowCommand,
  DescribeContactFlowModuleCommand,
} from '@aws-sdk/client-connect';
import { AWSConfig } from '@/types/contact.types';

/**
 * Flow Definition에서 Action 하나를 나타내는 인터페이스
 */
export interface FlowAction {
  Identifier: string;
  Type: string;
  Parameters?: Record<string, any>;
  Transitions?: {
    NextAction?: string;
    Errors?: Array<{ NextAction?: string; ErrorType?: string }>;
    Conditions?: Array<{
      NextAction?: string;
      Condition?: {
        Operator?: string;
        Operands?: string[];
      };
    }>;
  };
  Metadata?: {
    position?: { x: number; y: number };
  };
}

/**
 * Flow Definition 전체 구조
 */
export interface FlowDefinition {
  Version: string;
  StartAction?: string;
  Actions: FlowAction[];
  Metadata?: {
    entryPointPosition?: { x: number; y: number };
    snapToGrid?: boolean;
    ActionMetadata?: Record<string, any>;
  };
}

/**
 * ARN에서 instance_id와 flow_id/flow_module_id를 추출하는 함수
 */
export function extractIdsFromArn(arn: string): {
  instanceId: string | null;
  entityType: 'contact-flow' | 'flow-module' | null;
  entityId: string | null;
} {
  const match = arn.match(
    /arn:aws:connect:[a-z0-9-]+:\d+:instance\/([a-f0-9-]+)\/(?:(contact-flow|flow-module)\/([a-f0-9-]+))?/
  );

  if (match) {
    return {
      instanceId: match[1],
      entityType: match[2] as 'contact-flow' | 'flow-module' | null,
      entityId: match[3] || null,
    };
  }

  return {
    instanceId: null,
    entityType: null,
    entityId: null,
  };
}

/**
 * Flow Definition Service 클래스
 */
export class FlowDefinitionService {
  private connectClient: ConnectClient;
  private flowCache: Map<string, FlowDefinition> = new Map();

  constructor(config: AWSConfig) {
    const clientConfig: any = {
      region: config.region,
    };

    if (config.credentials) {
      clientConfig.credentials = {
        accessKeyId: config.credentials.accessKeyId,
        secretAccessKey: config.credentials.secretAccessKey,
        sessionToken: config.credentials.sessionToken,
        expiration: config.credentials.expiration
          ? new Date(config.credentials.expiration)
          : undefined,
      };
    }

    this.connectClient = new ConnectClient(clientConfig);
  }

  /**
   * Contact Flow 정의를 가져옵니다
   */
  async getContactFlowDefinition(
    instanceId: string,
    flowId: string
  ): Promise<FlowDefinition | null> {
    const cacheKey = `contact-flow:${instanceId}:${flowId}`;

    // Check cache first
    if (this.flowCache.has(cacheKey)) {
      return this.flowCache.get(cacheKey)!;
    }

    try {
      const command = new DescribeContactFlowCommand({
        InstanceId: instanceId,
        ContactFlowId: flowId,
      });

      const response = await this.connectClient.send(command);

      if (response.ContactFlow?.Content) {
        const content = JSON.parse(response.ContactFlow.Content);
        this.flowCache.set(cacheKey, content);
        return content;
      }

      return null;
    } catch (error) {
      console.error('Error fetching contact flow definition:', error);
      return null;
    }
  }

  /**
   * Contact Flow Module 정의를 가져옵니다
   */
  async getContactFlowModuleDefinition(
    instanceId: string,
    flowModuleId: string
  ): Promise<FlowDefinition | null> {
    const cacheKey = `flow-module:${instanceId}:${flowModuleId}`;

    // Check cache first
    if (this.flowCache.has(cacheKey)) {
      return this.flowCache.get(cacheKey)!;
    }

    try {
      const command = new DescribeContactFlowModuleCommand({
        InstanceId: instanceId,
        ContactFlowModuleId: flowModuleId,
      });

      const response = await this.connectClient.send(command);

      if (response.ContactFlowModule?.Content) {
        const content = JSON.parse(response.ContactFlowModule.Content);
        this.flowCache.set(cacheKey, content);
        return content;
      }

      return null;
    } catch (error) {
      console.error('Error fetching flow module definition:', error);
      return null;
    }
  }

  /**
   * ARN을 통해 Flow Definition을 가져옵니다
   */
  async getFlowDefinitionByArn(arn: string): Promise<FlowDefinition | null> {
    const { instanceId, entityType, entityId } = extractIdsFromArn(arn);

    if (!instanceId || !entityType || !entityId) {
      console.error('Invalid ARN format:', arn);
      return null;
    }

    if (entityType === 'contact-flow') {
      return this.getContactFlowDefinition(instanceId, entityId);
    } else if (entityType === 'flow-module') {
      return this.getContactFlowModuleDefinition(instanceId, entityId);
    }

    return null;
  }

  /**
   * CheckAttribute 블록에서 비교값을 가져옵니다
   *
   * @param flowArn - Contact Flow 또는 Flow Module ARN
   * @param blockId - Block Identifier
   * @param comparisonKeyword - Parameters에서 가져올 키 (예: "ComparisonValue")
   * @param isSecondValue - true면 Transitions의 Operands에서 값을 가져옴
   * @returns 비교값 또는 null
   */
  async getComparisonValue(
    flowArn: string,
    blockId: string,
    comparisonKeyword: string = 'ComparisonValue',
    isSecondValue: boolean = false
  ): Promise<string | null> {
    const flowDefinition = await this.getFlowDefinitionByArn(flowArn);

    if (!flowDefinition) {
      return null;
    }

    const targetBlock = flowDefinition.Actions.find(
      (action) => action.Identifier === blockId
    );

    if (!targetBlock) {
      return null;
    }

    if (!isSecondValue) {
      // Parameters에서 직접 가져오기
      return targetBlock.Parameters?.[comparisonKeyword] || null;
    } else {
      // Transitions의 Conditions에서 Operands 가져오기
      const conditions = targetBlock.Transitions?.Conditions;
      if (conditions && conditions.length > 0) {
        const operands = conditions[0].Condition?.Operands;
        if (operands && operands.length > 0) {
          const targetValue = operands[0];
          // "$"가 포함된 경우만 반환 (동적 값인 경우)
          return targetValue.includes('$') ? targetValue : null;
        }
      }
      return null;
    }
  }

  /**
   * Flow Definition에서 특정 블록의 모든 정보를 가져옵니다
   */
  async getBlockInfo(
    flowArn: string,
    blockId: string
  ): Promise<FlowAction | null> {
    const flowDefinition = await this.getFlowDefinitionByArn(flowArn);

    if (!flowDefinition) {
      return null;
    }

    return (
      flowDefinition.Actions.find((action) => action.Identifier === blockId) ||
      null
    );
  }

  /**
   * 캐시를 초기화합니다
   */
  clearCache(): void {
    this.flowCache.clear();
  }
}

// Export singleton pattern
let flowDefinitionServiceInstance: FlowDefinitionService | null = null;

export const getFlowDefinitionService = (
  config?: AWSConfig
): FlowDefinitionService => {
  if (config) {
    flowDefinitionServiceInstance = new FlowDefinitionService(config);
  }
  if (!flowDefinitionServiceInstance) {
    throw new Error(
      'FlowDefinitionService not initialized. Please provide config.'
    );
  }
  return flowDefinitionServiceInstance;
};

export const resetFlowDefinitionService = () => {
  flowDefinitionServiceInstance = null;
};

export default FlowDefinitionService;


---------------------
/Users/ke-aicc/Downloads/files/src/services/flowBuilderService.ts
---------------------
import { processLogsForDetailView } from '@/utils/logProcessor';
import { Position } from 'react-flow-renderer';
import { 
  ContactLog, 
  ContactFlowNode, 
  ContactFlowEdge, 
  ContactFlowData,
  ModuleType,
  LambdaLog,
  TranscriptEntry
} from '@/types/contact.types';

export interface NodePosition {
  x: number;
  y: number;
}

export interface LayoutOptions {
  nodeWidth: number;
  nodeHeight: number;
  horizontalSpacing: number;
  verticalSpacing: number;
  direction: 'LR' | 'TB' | 'RL' | 'BT';
}

const DEFAULT_LAYOUT_OPTIONS: LayoutOptions = {
  nodeWidth: 180,
  nodeHeight: 80,
  horizontalSpacing: 100,
  verticalSpacing: 80,
  direction: 'LR',
};

// Module type to Korean name mapping
const MODULE_NAME_MAP: Record<string, string> = {
  'SetLoggingBehavior': '로깅 동작 설정',
  'SetAttributes': '속성 설정',
  'SetFlowAttributes': '플로우 속성 설정',
  'PlayPrompt': '프롬프트 재생',
  'GetUserInput': '사용자 입력 받기',
  'StoreUserInput': '사용자 입력 저장',
  'InvokeExternalResource': '외부 리소스 호출',
  'InvokeLambdaFunction': 'Lambda 함수 호출',
  'CheckAttribute': '속성 확인',
  'Transfer': '전환',
  'TransferToQueue': '대기열로 전환',
  'TransferToFlow': '플로우로 전환',
  'Disconnect': '연결 끊기',
  'Wait': '대기',
  'Loop': '반복',
  'SetContactFlow': '컨택 플로우 설정',
  'SetWhisperFlow': '위스퍼 플로우 설정',
  'SetHoldFlow': '대기 플로우 설정',
  'SetCustomerQueueFlow': '고객 대기열 플로우 설정',
  'SetEventHook': '이벤트 훅 설정',
  'GetCustomerProfile': '고객 프로필 조회',
  'AssociateContactToCustomerProfile': '고객 프로필 연결',
  'TagContact': '태그 지정',
  'InvokeFlowModule': '플로우 모듈 호출',
  'ReturnFromFlowModule': '플로우 모듈 반환',
  'Resume': '재개',
  'Dial': '다이얼',
};

// Error keywords for detection
const ERROR_KEYWORDS = [
  'Error',
  'Failed',
  'Timeout',
  'Exception',
  'Invalid',
  'not found',
  'NotDone',
  'MultipleFound',
];

// Module types to skip or consolidate
const SKIP_MODULE_TYPES = ['null'];
const CONSOLIDATE_MODULE_TYPES = ['SetAttributes', 'SetFlowAttributes'];

export class FlowBuilderService {
  private originalLogs: ContactLog[];
  private logs: ContactLog[];
  private nodes: Map<string, ContactFlowNode>;
  private edges: ContactFlowEdge[];
  private nodePositions: Map<string, NodePosition>;
  private layoutOptions: LayoutOptions;
  private filterModules: boolean;

  constructor(logs: ContactLog[], options?: Partial<LayoutOptions> & { filterModules?: boolean }) {
    this.originalLogs = logs; // 원본 로그 저장
    this.filterModules = options?.filterModules ?? true;
    this.logs = this.preprocessLogs(logs);

    this.nodes = new Map();
    this.edges = [];
    this.nodePositions = new Map();
    this.layoutOptions = { ...DEFAULT_LAYOUT_OPTIONS, ...options };
  }

  /**
   * Build the complete flow diagram
   */
  public buildFlow(): ContactFlowData {
    this.generateNodeIds();
    this.createNodes();
    this.createEdges();
    this.calculateLayout();
    this.applyPositions();

    return {
      nodes: Array.from(this.nodes.values()),
      edges: this.edges,
      logs: this.logs,
    };
  }

  /**
   * Add Lambda logs to the flow
   */
  public addLambdaLogs(lambdaLogs: Record<string, LambdaLog[]>): void {
    for (const [functionName, logs] of Object.entries(lambdaLogs)) {
      const relatedNodes = Array.from(this.nodes.values()).filter(
        node => node.data.moduleType === 'InvokeExternalResource' &&
                this.extractFunctionName(node.data.parameters?.FunctionArn) === functionName
      );

      for (const node of relatedNodes) {
        const nodeLogs = logs.filter(log => 
          Math.abs(new Date(log.timestamp).getTime() - new Date(node.data.timestamp!).getTime()) < 5000
        );
        
        if (nodeLogs.length > 0) {
          node.data.parameters = {
            ...node.data.parameters,
            lambdaLogs: nodeLogs,
          };
        }
      }
    }
  }

  /**
   * Add transcript to the flow
   */
  public addTranscript(transcript: TranscriptEntry[]): void {
    // Create transcript nodes for visualization
    let lastNodeId: string | null = null;
    let yOffset = 0;

    for (const entry of transcript) {
      const nodeId = `transcript_${entry.Id}`;
      const node: ContactFlowNode = {
        id: nodeId,
        type: 'transcript',
        data: {
          label: entry.Content.substring(0, 50) + (entry.Content.length > 50 ? '...' : ''),
          moduleType: 'Transcript',
          parameters: {
            participantRole: entry.ParticipantRole,
            content: entry.Content,
            sentiment: entry.Sentiment,
            time: entry.AbsoluteTime,
          },
        },
        position: {
          x: this.layoutOptions.nodeWidth * 2,
          y: yOffset,
        },
        style: {
          background: entry.ParticipantRole === 'AGENT' ? '#E3F2FD' : '#FFF3E0',
          border: '1px solid #90A4AE',
        },
      };

      this.nodes.set(nodeId, node);
      
      if (lastNodeId) {
        this.edges.push({
          id: `${lastNodeId}_${nodeId}`,
          source: lastNodeId,
          target: nodeId,
          type: 'smoothstep',
          animated: false,
        });
      }
      
      lastNodeId = nodeId;
      yOffset += this.layoutOptions.verticalSpacing;
    }
  }

  /**
   * Check if a log is from a Module (has MOD_ in ContactFlowName and ModuleExecutionStack)
   */
  private isModuleFlow(log: ContactLog): boolean {
    return log.ContactFlowName?.includes('MOD_') &&
           Array.isArray(log.ModuleExecutionStack) &&
           log.ModuleExecutionStack.length > 0;
  }

  /**
   * Preprocess logs (filter, sort, etc.)
   * Filters out Module flows (MOD_) from main flow view
   */
  private preprocessLogs(logs: ContactLog[]): ContactLog[] {
    return logs
      .filter(log => {
        // Skip specific module types
        if (SKIP_MODULE_TYPES.includes(log.ContactFlowModuleType)) {
          return false;
        }
        // Filter out Module flows (MOD_) from main view if filterModules is true
        if (this.filterModules && this.isModuleFlow(log)) {
          return false;
        }
        return true;
      })
      .sort((a, b) => new Date(a.Timestamp).getTime() - new Date(b.Timestamp).getTime());
  }

  /**
   * Generate unique node IDs for logs based on ContactFlowName
   * Groups consecutive logs by ContactFlowName for time-based chunking
   */
  private generateNodeIds(): void {
    const flowCounts = new Map<string, number>();
    let lastFlowName: string | null = null;
    let lastNodeId: string | null = null;

    for (const log of this.logs) {
      const flowName = log.ContactFlowName;

      // Group consecutive logs with same ContactFlowName into same node
      if (flowName === lastFlowName && lastNodeId) {
        log.node_id = lastNodeId;
      } else {
        const count = (flowCounts.get(flowName) || 0) + 1;
        flowCounts.set(flowName, count);
        lastNodeId = `${flowName}_${count}`;
        log.node_id = lastNodeId;
        lastFlowName = flowName;
      }
    }
  }

  /**
   * Create nodes from logs
   * Groups logs by node_id for time-based chunking
   */
  private createNodes(): void {
    // Group logs by node_id
    const logsByNodeId = new Map<string, ContactLog[]>();

    for (const log of this.logs) {
      const nodeId = log.node_id!;
      if (!logsByNodeId.has(nodeId)) {
        logsByNodeId.set(nodeId, []);
      }
      logsByNodeId.get(nodeId)!.push(log);
    }

    // Create one node per group with sequence number
    let sequenceNumber = 1;
    for (const [nodeId, logs] of logsByNodeId.entries()) {
      // Use first log for node metadata, but store all logs
      const firstLog = logs[0];
      const hasError = logs.some(log => this.detectError(log));
      const node = this.createNodeFromLogs(firstLog, logs, hasError, sequenceNumber);
      this.nodes.set(node.id, node);
      sequenceNumber++;
    }
  }

  /**
   * Consolidate consecutive logs of same type
   */
  private consolidateLogs(): ContactLog[] {
    const consolidated: ContactLog[] = [];
    let currentGroup: ContactLog[] = [];
    let currentType: string | null = null;

    for (const log of this.logs) {
      if (CONSOLIDATE_MODULE_TYPES.includes(log.ContactFlowModuleType)) {
        if (log.ContactFlowModuleType === currentType) {
          currentGroup.push(log);
        } else {
          if (currentGroup.length > 0) {
            consolidated.push(this.mergeLogGroup(currentGroup));
          }
          currentGroup = [log];
          currentType = log.ContactFlowModuleType;
        }
      } else {
        if (currentGroup.length > 0) {
          consolidated.push(this.mergeLogGroup(currentGroup));
          currentGroup = [];
          currentType = null;
        }
        consolidated.push(log);
      }
    }

    if (currentGroup.length > 0) {
      consolidated.push(this.mergeLogGroup(currentGroup));
    }

    return consolidated;
  }

  /**
   * Merge a group of logs into one
   */
  private mergeLogGroup(logs: ContactLog[]): ContactLog {
    const merged = { ...logs[0] };
    
    if (logs.length > 1) {
      merged.Parameters = logs.map(log => log.Parameters).filter(Boolean);
      merged.Results = logs.map(log => log.Results).filter(Boolean).join(', ');
    }
    
    return merged;
  }

  /**
   * Create a single node from grouped logs (time-based chunking)
   * In main flow view, use ContactFlowName as label
   * Stores all chunked logs in the node data
   */
  private createNodeFromLogs(firstLog: ContactLog, allLogs: ContactLog[], isError: boolean, sequenceNumber: number): ContactFlowNode {
    const moduleType = 'InvokeFlowModule'; // 아이콘 통일
    const nodeLabel = firstLog.ContactFlowName;

    // Calculate time range for this node
    const timestamps = allLogs.map(log => new Date(log.Timestamp).getTime());
    const minTimestamp = new Date(Math.min(...timestamps));
    const maxTimestamp = new Date(Math.max(...timestamps));

    // 상세 뷰의 노드 개수를 정확하게 계산
    const nodeOriginalLogs = this.originalLogs.filter(log => {
      const logTime = new Date(log.Timestamp).getTime();
      return logTime >= minTimestamp.getTime() && logTime <= maxTimestamp.getTime();
    });
    const detailNodes = processLogsForDetailView(nodeOriginalLogs);
    const detailNodeCount = detailNodes.length;

    return {
      id: firstLog.node_id || `node_${Date.now()}_${Math.random()}`,
      type: 'custom',
      data: {
        label: nodeLabel,
        moduleType,
        parameters: firstLog.Parameters,
        results: firstLog.Results,
        error: isError,
        timestamp: firstLog.Timestamp,
        duration: this.calculateDuration(firstLog),
        chunkedLogs: allLogs,
        timeRange: {
          start: minTimestamp.toISOString(),
          end: maxTimestamp.toISOString(),
        },
        logCount: detailNodeCount, // 정확한 상세 노드 개수
      },
      position: { x: 0, y: 0 }, // Will be calculated later
      style: {
        background: isError ? '#FFEBEE' : '#F5F5F5',
        border: isError ? '2px solid #F44336' : '1px solid #E0E0E0',
        borderRadius: '8px',
        padding: '10px',
      },
    };
  }

  /**
   * Define the actual module type
   */
  private defineModuleType(log: ContactLog): string {
    const moduleType = log.ContactFlowModuleType;
    
    if (moduleType === 'SetContactFlow') {
      const flowType = log.Parameters?.Type;
      switch (flowType) {
        case 'CustomerHold':
        case 'AgentHold':
          return 'SetHoldFlow';
        case 'CustomerWhisper':
        case 'AgentWhisper':
          return 'SetWhisperFlow';
        case 'CustomerQueue':
          return 'SetCustomerQueueFlow';
        case 'DefaultAgentUI':
          return 'SetEventHook';
        default:
          return moduleType;
      }
    }
    
    return moduleType;
  }

  /**
   * Get node content (text and footer)
   */
  private getNodeContent(log: ContactLog): { nodeText: string; nodeFooter: string } {
    const moduleType = log.ContactFlowModuleType;
    const params = log.Parameters || {};
    let nodeText = '';
    let nodeFooter = '';

    switch (moduleType) {
      case 'CheckAttribute':
        const op = params.ComparisonMethod;
        const value = params.Value;
        const secondValue = params.SecondValue;
        const operatorSymbol = this.getOperatorSymbol(op);
        nodeText = `${value} ${operatorSymbol} ${secondValue}`;
        nodeFooter = `Results: ${log.Results}`;
        break;

      case 'InvokeExternalResource':
      case 'InvokeLambdaFunction':
        if (params.Parameters) {
          const functionParams = Object.entries(params.Parameters)
            .map(([key, value]) => `${key}: ${value}`)
            .join('\n');
          nodeText = functionParams;
        }
        if (log.ExternalResults) {
          const success = log.ExternalResults.isSuccess === 'true';
          nodeFooter = success ? 'Success ✅' : 'Failed ❌';
        } else {
          nodeFooter = log.Results || '';
        }
        break;

      case 'PlayPrompt':
      case 'GetUserInput':
      case 'StoreUserInput':
        nodeText = params.Text || params.PromptLocation || '';
        nodeFooter = log.Results ? `Results: ${log.Results}` : '';
        break;

      case 'SetAttributes':
      case 'SetFlowAttributes':
        if (Array.isArray(params)) {
          nodeText = params.map(p => `${p.Key}: ${p.Value}`).join('\n');
        } else {
          nodeText = Object.entries(params)
            .map(([key, value]) => `${key}: ${value}`)
            .join('\n');
        }
        break;

      case 'TagContact':
        if (params.Tags) {
          nodeText = Object.entries(params.Tags)
            .map(([key, value]) => `${key}: ${value}`)
            .join('\n');
        }
        break;

      default:
        nodeText = JSON.stringify(params, null, 2);
        nodeFooter = log.Results || '';
    }

    // Truncate long text
    nodeText = this.truncateText(nodeText, 200);
    nodeFooter = this.truncateText(nodeFooter, 100);

    return { nodeText, nodeFooter };
  }

  /**
   * Create edges between nodes with proper handle IDs
   * Sequential flow from left to right, wrapping to next row
   */
  private createEdges(): void {
    const nodeArray = Array.from(this.nodes.values());

    for (let i = 0; i < nodeArray.length - 1; i++) {
      const source = nodeArray[i];
      const target = nodeArray[i + 1];

      // Get source and target handle IDs based on positions
      const sourceHandleId = this.getHandleId('source', source.data.sourcePosition || Position.Right);
      const targetHandleId = this.getHandleId('target', target.data.targetPosition || Position.Left);

      this.edges.push({
        id: `${source.id}_${target.id}`,
        source: source.id,
        target: target.id,
        sourceHandle: sourceHandleId,
        targetHandle: targetHandleId,
        type: 'smoothstep',
        animated: false,
        style: {
          stroke: source.data.error ? '#F44336' : '#B0B0B0',
          strokeWidth: 2,
        },
        label: `${i + 1}`,
      });
    }
  }

  /**
   * Get handle ID based on type and position
   */
  private getHandleId(type: 'source' | 'target', position: Position): string {
    const positionMap: Record<Position, string> = {
      [Position.Top]: 'top',
      [Position.Bottom]: 'bottom',
      [Position.Left]: 'left',
      [Position.Right]: 'right',
    };
    return `${type}-${positionMap[position]}`;
  }

  /**
   * Calculate layout positions in a "ㄹ" (rieul) pattern
   * - Row 0: left to right
   * - Row 1: right to left
   * - Row 2: left to right
   * - And so on...
   */
  private calculateLayout(): void {
    const nodeArray = Array.from(this.nodes.values());

    // Grid layout with 5 columns
    const columns = 5;
    const nodeWidth = 280;
    const nodeHeight = 180;
    const horizontalGap = 40;
    const verticalGap = 80;

    for (let i = 0; i < nodeArray.length; i++) {
      const node = nodeArray[i];
      const row = Math.floor(i / columns);
      const isEvenRow = row % 2 === 0;

      // For even rows (0, 2, 4...): normal left-to-right
      // For odd rows (1, 3, 5...): reversed right-to-left
      let column: number;
      if (isEvenRow) {
        column = i % columns;
      } else {
        column = columns - 1 - (i % columns);
      }

      const x = column * (nodeWidth + horizontalGap);
      const y = row * (nodeHeight + verticalGap);

      this.nodePositions.set(node.id, { x, y });

      // Determine handle positions based on flow direction
      const hasNextNode = i < nodeArray.length - 1;
      const isLastInRow = (i + 1) % columns === 0;
      const isFirstInRow = i % columns === 0;

      if (hasNextNode) {
        if (isLastInRow) {
          // Transition to next row
          node.data.sourcePosition = Position.Bottom;
        } else {
          // Continue in same row
          if (isEvenRow) {
            // Even row: flow left to right
            node.data.sourcePosition = Position.Right;
          } else {
            // Odd row: flow right to left
            node.data.sourcePosition = Position.Left;
          }
        }
      }

      // Target position (where this node receives from)
      if (i === 0) {
        // First node
        node.data.targetPosition = Position.Left;
      } else if (isFirstInRow && row > 0) {
        // First node in row (receiving from previous row)
        node.data.targetPosition = Position.Top;
      } else {
        // Receiving from same row
        if (isEvenRow) {
          // Even row: receive from left
          node.data.targetPosition = Position.Left;
        } else {
          // Odd row: receive from right
          node.data.targetPosition = Position.Right;
        }
      }
    }
  }

  /**
   * Apply calculated positions to nodes
   */
  private applyPositions(): void {
    for (const [nodeId, position] of this.nodePositions.entries()) {
      const node = this.nodes.get(nodeId);
      if (node) {
        node.position = position;
      }
    }
  }

  /**
   * Detect if log contains error
   */
  private detectError(log: ContactLog): boolean {
    const results = log.Results || '';
    const externalResults = JSON.stringify(log.ExternalResults || {});
    
    return ERROR_KEYWORDS.some(keyword => 
      results.includes(keyword) || externalResults.includes(keyword)
    );
  }

  /**
   * Get operator symbol
   */
  private getOperatorSymbol(operator: string): string {
    const symbols: Record<string, string> = {
      'Contains': '⊃',
      'Equals': '=',
      'GreaterThan': '>',
      'GreaterThanOrEqualTo': '≥',
      'LessThan': '<',
      'LessThanOrEqualTo': '≤',
      'StartsWith': 'SW',
    };
    return symbols[operator] || operator;
  }

  /**
   * Extract function name from ARN
   */
  private extractFunctionName(arn?: string): string {
    if (!arn) return '';
    const parts = arn.split(':');
    return parts[parts.length - 1];
  }

  /**
   * Calculate duration for a module
   */
  private calculateDuration(log: ContactLog): number {
    // This would need to be calculated based on the next log's timestamp
    // For now, return 0
    return 0;
  }

  /**
   * Truncate text to specified length
   */
  private truncateText(text: string, maxLength: number): string {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }
}

export default FlowBuilderService;


---------------------
/Users/ke-aicc/Downloads/files/src/services/credentialService.ts
---------------------
/**
 * Credential Service
 * 백엔드 API를 통해 AWS SSO 자격 증명을 가져옵니다.
 */

export interface AWSCredentials {
  accessKeyId: string;
  secretAccessKey: string;
  sessionToken?: string;
  expiration?: string;
}

/**
 * 백엔드 API를 통해 SSO 자격 증명을 가져옵니다.
 *
 * 사용 방법:
 * 1. 백엔드 서버에서 `aws sso login --profile <profile-name>`을 먼저 실행
 * 2. 백엔드 API에서 credential을 읽어서 반환
 * 3. 프론트엔드에서 이 함수를 호출하여 credential을 받음
 *
 * @param profile - AWS SSO 프로필 이름
 * @returns AWS 자격 증명
 */
export async function fetchSSOCredentials(profile?: string): Promise<AWSCredentials> {
  try {
    const response = await fetch('/api/aws/credentials', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ profile }),
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch credentials: ${response.statusText}`);
    }

    const credentials = await response.json();
    return credentials;
  } catch (error) {
    console.error('Error fetching SSO credentials:', error);
    throw new Error(
      'SSO 자격 증명을 가져올 수 없습니다. 백엔드 서버가 실행 중인지 확인하세요.'
    );
  }
}

/**
 * 환경 변수에서 자격 증명을 가져옵니다 (개발용)
 * .env 파일에 다음 값을 설정하세요:
 * REACT_APP_AWS_ACCESS_KEY_ID=your_access_key
 * REACT_APP_AWS_SECRET_ACCESS_KEY=your_secret_key
 * REACT_APP_AWS_SESSION_TOKEN=your_session_token (선택사항)
 */
export function getCredentialsFromEnv(): AWSCredentials | null {
  const accessKeyId = process.env.REACT_APP_AWS_ACCESS_KEY_ID;
  const secretAccessKey = process.env.REACT_APP_AWS_SECRET_ACCESS_KEY;
  const sessionToken = process.env.REACT_APP_AWS_SESSION_TOKEN;

  if (!accessKeyId || !secretAccessKey) {
    return null;
  }

  return {
    accessKeyId,
    secretAccessKey,
    sessionToken,
  };
}

/**
 * 백엔드 API를 통해 현재 AWS SSO 프로필에서 자격 증명을 자동으로 가져옵니다.
 * 이 함수는 사용자가 이미 aws sso login을 실행한 상태를 가정합니다.
 */
export async function autoFetchSSOCredentials(): Promise<{
  credentials: AWSCredentials;
  profile: string;
  region: string;
} | null> {
  try {
    const response = await fetch('/api/aws/auto-credentials', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error auto-fetching SSO credentials:', error);
    return null;
  }
}

/**
 * 백엔드 API를 통해 AWS 프로필에서 리전 정보를 가져옵니다.
 */
export async function getRegionFromProfile(profile?: string): Promise<string | null> {
  try {
    const response = await fetch('/api/aws/region', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ profile }),
    });

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    return data.region;
  } catch (error) {
    console.error('Error fetching region from profile:', error);
    return null;
  }
}

/**
 * AWS SDK v3 호환 Credential Provider를 생성합니다.
 * 이 Provider는 자격 증명이 만료되기 전에 자동으로 갱신합니다.
 */
export function createAutoRenewingCredentialProvider(profile?: string) {
  let cachedCredentials: AWSCredentials | null = null;
  let refreshPromise: Promise<AWSCredentials> | null = null;

  return async () => {
    // 1. Check if we have valid cached credentials
    if (cachedCredentials) {
      const now = new Date();
      // If expiration is missing, assume valid (or let SDK handle it)
      // If expiration exists, check if it's expired or expiring soon (within 5 mins)
      if (cachedCredentials.expiration) {
        const expiration = new Date(cachedCredentials.expiration);
        const fiveMinutesFromNow = new Date(now.getTime() + 5 * 60 * 1000);

        if (expiration > fiveMinutesFromNow) {
          return {
            accessKeyId: cachedCredentials.accessKeyId,
            secretAccessKey: cachedCredentials.secretAccessKey,
            sessionToken: cachedCredentials.sessionToken,
            expiration: expiration,
          };
        }
      } else {
        // If no expiration provided, just return what we have
        // The SDK might fail if it's actually expired, but we can't know
        return {
          accessKeyId: cachedCredentials.accessKeyId,
          secretAccessKey: cachedCredentials.secretAccessKey,
          sessionToken: cachedCredentials.sessionToken,
        };
      }
    }

    // 2. Refresh credentials
    if (!refreshPromise) {
      refreshPromise = (async () => {
        try {
          console.log('Refreshing AWS credentials...');
          let newCreds: AWSCredentials;

          if (profile) {
            newCreds = await fetchSSOCredentials(profile);
          } else {
            // Try auto-fetch if no profile specified
            const result = await autoFetchSSOCredentials();
            if (result) {
              newCreds = result.credentials;
            } else {
              throw new Error('Failed to auto-fetch credentials');
            }
          }

          cachedCredentials = newCreds;
          return newCreds;
        } finally {
          refreshPromise = null;
        }
      })();
    }

    const creds = await refreshPromise;

    return {
      accessKeyId: creds.accessKeyId,
      secretAccessKey: creds.secretAccessKey,
      sessionToken: creds.sessionToken,
      expiration: creds.expiration ? new Date(creds.expiration) : undefined,
    };
  };
}


---------------------
/Users/ke-aicc/Downloads/files/src/services/awsConnectService.ts
---------------------
import {
  ConnectClient,
  DescribeContactCommand,
  SearchContactsCommand,
  GetContactAttributesCommand,
  ListInstancesCommand,
} from '@aws-sdk/client-connect';
import {
  CloudWatchLogsClient,
  StartQueryCommand,
  GetQueryResultsCommand,
  QueryStatus,
} from '@aws-sdk/client-cloudwatch-logs';
import {
  S3Client,
  GetObjectCommand,
  ListObjectsV2Command,
} from '@aws-sdk/client-s3';
import {
  XRayClient,
  GetTraceGraphCommand,
  GetTraceSummariesCommand,
} from '@aws-sdk/client-xray';
import pako from 'pako';
import {
  ContactLog,
  LambdaLog,
  ContactDetails,
  TranscriptEntry,
  AWSConfig,
  SearchCriteria,
  ApiResponse
} from '@/types/contact.types';
import { createAutoRenewingCredentialProvider } from './credentialService';

export class AWSConnectService {
  private connectClient: ConnectClient;
  private logsClient: CloudWatchLogsClient;
  private s3Client: S3Client;
  private xrayClient: XRayClient;
  private config: AWSConfig;

  constructor(config: AWSConfig) {
    this.config = config;

    // Browser environment - only use explicitly provided credentials
    // For SSO, credentials should be obtained from backend API and passed here
    const clientConfig: any = {
      region: config.region,
    };

    // Only add credentials if they are explicitly provided
    if (config.profile) {
      // Use auto-renewing provider if profile is set
      clientConfig.credentials = createAutoRenewingCredentialProvider(config.profile);
    } else if (config.credentials) {
      clientConfig.credentials = {
        accessKeyId: config.credentials.accessKeyId,
        secretAccessKey: config.credentials.secretAccessKey,
        sessionToken: config.credentials.sessionToken,
        expiration: config.credentials.expiration
          ? new Date(config.credentials.expiration)
          : undefined,
      };
    }

    this.connectClient = new ConnectClient(clientConfig);
    this.logsClient = new CloudWatchLogsClient(clientConfig);
    this.s3Client = new S3Client(clientConfig);
    this.xrayClient = new XRayClient(clientConfig);
  }

  /**
   * Connect 인스턴스 목록 조회
   */
  async listInstances(): Promise<Array<{ id: string; alias: string; arn: string }>> {
    try {
      const command = new ListInstancesCommand({});
      const response = await this.connectClient.send(command);

      return (response.InstanceSummaryList || []).map(instance => ({
        id: instance.Id!,
        alias: instance.InstanceAlias || instance.Id!,
        arn: instance.Arn!,
      }));
    } catch (error) {
      console.error('Error listing Connect instances:', error);
      throw error;
    }
  }

  /**
   * Contact 상세 정보 조회
   */
  async getContactDetails(contactId: string): Promise<ContactDetails> {
    try {
      const command = new DescribeContactCommand({
        InstanceId: this.config.instanceId,
        ContactId: contactId,
      });

      const response = await this.connectClient.send(command);
      const contact = response.Contact!;

      return {
        contactId: contact.Id!,
        instanceId: this.config.instanceId,
        initiationTimestamp: contact.InitiationTimestamp!.toISOString(),
        disconnectTimestamp: contact.DisconnectTimestamp?.toISOString(),
        channel: contact.Channel || 'VOICE',
        queueName: contact.QueueInfo ? 'Queue' : undefined,
        agentName: contact.AgentInfo ? 'Agent' : undefined,
        duration: this.calculateDuration(
          contact.InitiationTimestamp!,
          contact.DisconnectTimestamp
        ),
      };
    } catch (error) {
      console.error('Error fetching contact details:', error);
      throw error;
    }
  }

  /**
   * Contact 로그 조회 (CloudWatch Logs)
   */
  async getContactLogs(
    contactId: string,
    startTime: Date,
    endTime: Date
  ): Promise<ContactLog[]> {
    const query = `
      fields @timestamp, @message
      | filter ContactId = "${contactId}"
      | sort @timestamp asc
    `;

    try {
      const startQueryCommand = new StartQueryCommand({
        logGroupName: this.config.logGroupName,
        startTime: Math.floor(startTime.getTime() / 1000),
        endTime: Math.floor(endTime.getTime() / 1000),
        queryString: query,
      });

      const startQueryResponse = await this.logsClient.send(startQueryCommand);
      const queryId = startQueryResponse.queryId!;

      // Poll for results
      let status: QueryStatus | string = QueryStatus.Running;
      let results: any[] = [];

      while (status === QueryStatus.Running || status === QueryStatus.Scheduled) {
        await new Promise(resolve => setTimeout(resolve, 1000));

        const getQueryResultsCommand = new GetQueryResultsCommand({
          queryId,
        });

        const queryResults = await this.logsClient.send(getQueryResultsCommand);
        status = queryResults.status as QueryStatus;

        if (status === QueryStatus.Complete) {
          results = queryResults.results || [];
        }
      }

      return this.parseCloudWatchLogs(results);
    } catch (error) {
      console.error('Error fetching contact logs:', error);
      throw error;
    }
  }

  /**
   * S3에서 Transcript 조회
   */
  async getTranscript(
    contactId: string,
    timestamp: Date
  ): Promise<TranscriptEntry[]> {
    const bucket = `${this.config.s3BucketPrefix}-s3-acn-storage`;
    const dateStr = timestamp.toISOString().split('T')[0].replace(/-/g, '/');
    const prefix = `Analysis/Voice/${dateStr}/${contactId}`;

    try {
      const listCommand = new ListObjectsV2Command({
        Bucket: bucket,
        Prefix: prefix,
      });

      const listResponse = await this.s3Client.send(listCommand);

      if (!listResponse.Contents || listResponse.Contents.length === 0) {
        return [];
      }

      const key = listResponse.Contents[0].Key!;
      const getCommand = new GetObjectCommand({
        Bucket: bucket,
        Key: key,
      });

      const getResponse = await this.s3Client.send(getCommand);
      const bodyString = await this.streamToString(getResponse.Body);
      const data = JSON.parse(bodyString);

      return data.Transcript || [];
    } catch (error) {
      console.error('Error fetching transcript:', error);
      return [];
    }
  }

  /**
   * S3에서 Datadog 백업 로그 조회 (압축 해제)
   */
  async getDatadogLogs(
    contactId: string,
    startTime: Date,
    endTime: Date
  ): Promise<{ contactLogs: ContactLog[], lambdaLogs: Record<string, LambdaLog[]> }> {
    const bucket = `${this.config.s3BucketPrefix}-s3-adf-datadog-backup`;
    const dateStr = startTime.toISOString().split('T')[0].replace(/-/g, '/');
    const prefix = dateStr;

    try {
      const listCommand = new ListObjectsV2Command({
        Bucket: bucket,
        Prefix: prefix,
      });

      const listResponse = await this.s3Client.send(listCommand);

      if (!listResponse.Contents) {
        return { contactLogs: [], lambdaLogs: {} };
      }

      const contactLogs: ContactLog[] = [];
      const lambdaLogs: Record<string, LambdaLog[]> = {};

      for (const object of listResponse.Contents) {
        const key = object.Key!;

        // Check if file is within time range
        const fileTime = this.extractTimeFromKey(key);
        if (!fileTime || fileTime < startTime || fileTime > endTime) {
          continue;
        }

        const getCommand = new GetObjectCommand({
          Bucket: bucket,
          Key: key,
        });

        const getResponse = await this.s3Client.send(getCommand);
        const bodyBuffer = await this.streamToBuffer(getResponse.Body);

        // Decompress gzip
        const decompressed = pako.ungzip(bodyBuffer, { to: 'string' });
        const lines = decompressed.split('\n').filter(line => line.trim());

        for (const line of lines) {
          try {
            const log = JSON.parse(line);

            if (log.ContactId === contactId) {
              if (log.logGroup?.includes('/aws/connect/')) {
                contactLogs.push(this.transformToContactLog(log));
              } else if (log.logGroup?.includes('/aws/lambda/')) {
                const functionName = this.extractFunctionName(log.logGroup);
                if (!lambdaLogs[functionName]) {
                  lambdaLogs[functionName] = [];
                }
                lambdaLogs[functionName].push(this.transformToLambdaLog(log));
              }
            }
          } catch (e) {
            // Skip invalid JSON lines
          }
        }
      }

      return { contactLogs, lambdaLogs };
    } catch (error) {
      console.error('Error fetching Datadog logs:', error);
      return { contactLogs: [], lambdaLogs: {} };
    }
  }

  /**
   * Lambda 로그 조회 (특정 함수)
   */
  async getLambdaLogs(
    contactId: string,
    functionName: string,
    startTime: Date,
    endTime: Date
  ): Promise<LambdaLog[]> {
    const logGroupName = `/aws/lambda/${functionName}`;
    const query = `
      fields @timestamp, @message
      | filter @message like /${contactId}/
      | sort @timestamp asc
    `;

    try {
      const logs = await this.queryCloudWatchLogs(
        logGroupName,
        query,
        startTime,
        endTime
      );

      return logs.map(log => this.transformToLambdaLog(log));
    } catch (error) {
      console.error(`Error fetching Lambda logs for ${functionName}:`, error);
      return [];
    }
  }

  /**
   * X-Ray 트레이스 조회 (상세 세그먼트 포함)
   */
  async getXRayTrace(traceId: string): Promise<any> {
    try {
      const now = new Date();
      const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);

      const summariesCommand = new GetTraceSummariesCommand({
        StartTime: yesterday,
        EndTime: now,
        FilterExpression: `id("${traceId}")`,
      });

      const summariesResponse = await this.xrayClient.send(summariesCommand);

      if (!summariesResponse.TraceSummaries || summariesResponse.TraceSummaries.length === 0) {
        return { segments: [], lambdaLogs: [] };
      }

      const graphCommand = new GetTraceGraphCommand({
        TraceIds: [traceId],
      });

      const graphResponse = await this.xrayClient.send(graphCommand);

      // Process segments to extract detailed information
      const segments = (graphResponse.Services || []).flatMap(service => {
        const segments: any[] = [];

        // Parse segment document
        if (service.Edges) {
          for (const edge of service.Edges) {
            const segment = {
              id: edge.ReferenceId,
              name: service.Name,
              origin: service.Type,
              parent_id: edge.StartTime, // This is a simplification
              start_time: service.StartTime,
              end_time: service.EndTime,
              error: !!service.SummaryStatistics?.ErrorStatistics?.TotalCount,
              fault: !!service.SummaryStatistics?.FaultStatistics?.TotalCount,
              subsegments: [],
            };

            segments.push(segment);
          }
        } else {
          // Single segment
          const segment = {
            id: `${service.Name}-${Date.now()}`,
            name: service.Name,
            origin: service.Type,
            start_time: service.StartTime,
            end_time: service.EndTime,
            error: !!service.SummaryStatistics?.ErrorStatistics?.TotalCount,
            fault: !!service.SummaryStatistics?.FaultStatistics?.TotalCount,
            subsegments: [],
          };

          segments.push(segment);
        }

        return segments;
      });

      return {
        traceId,
        summary: summariesResponse.TraceSummaries[0],
        segments,
        lambdaLogs: [], // To be populated separately if needed
      };
    } catch (error) {
      console.error('Error fetching X-Ray trace:', error);
      return { segments: [], lambdaLogs: [] };
    }
  }

  /**
   * Contact 검색
   */
  async searchContacts(criteria: SearchCriteria): Promise<ContactDetails[]> {
    try {
      const command = new SearchContactsCommand({
        InstanceId: this.config.instanceId,
        TimeRange: criteria.startTime && criteria.endTime ? {
          Type: 'INITIATION_TIMESTAMP',
          StartTime: criteria.startTime,
          EndTime: criteria.endTime,
        } : undefined,
        SearchCriteria: criteria.channel ? {
          Channels: criteria.channel as any,
          // Add more criteria as needed
        } : undefined,
        MaxResults: 100,
      });

      const response = await this.connectClient.send(command);

      return (response.Contacts || []).map(contact => ({
        contactId: contact.Id!,
        instanceId: this.config.instanceId,
        initiationTimestamp: contact.InitiationTimestamp!.toISOString(),
        disconnectTimestamp: contact.DisconnectTimestamp?.toISOString(),
        channel: contact.Channel || 'VOICE',
        agentName: contact.AgentInfo?.Id,
        queueName: contact.QueueInfo?.Id,
        contactFlowName: contact.Name,
      }));
    } catch (error) {
      console.error('Error searching contacts:', error);
      throw error;
    }
  }

  // Helper methods
  private async queryCloudWatchLogs(
    logGroupName: string,
    query: string,
    startTime: Date,
    endTime: Date
  ): Promise<any[]> {
    const startQueryCommand = new StartQueryCommand({
      logGroupName,
      startTime: Math.floor(startTime.getTime() / 1000),
      endTime: Math.floor(endTime.getTime() / 1000),
      queryString: query,
    });

    const startQueryResponse = await this.logsClient.send(startQueryCommand);
    const queryId = startQueryResponse.queryId!;

    let status: QueryStatus | string = QueryStatus.Running;
    let results: any[] = [];

    while (status === QueryStatus.Running || status === QueryStatus.Scheduled) {
      await new Promise(resolve => setTimeout(resolve, 1000));

      const getQueryResultsCommand = new GetQueryResultsCommand({
        queryId,
      });

      const queryResults = await this.logsClient.send(getQueryResultsCommand);
      status = queryResults.status as QueryStatus;

      if (status === QueryStatus.Complete) {
        results = queryResults.results || [];
      }
    }

    return results;
  }

  private parseCloudWatchLogs(results: any[]): ContactLog[] {
    return results.map(result => {
      const message = result.find((field: any) => field.field === '@message')?.value;
      const timestamp = result.find((field: any) => field.field === '@timestamp')?.value;

      try {
        const parsed = JSON.parse(message);
        return {
          ...parsed,
          Timestamp: timestamp || parsed.Timestamp,
        };
      } catch {
        return {
          ContactId: '',
          ContactFlowId: '',
          ContactFlowName: '',
          ContactFlowModuleType: '',
          Timestamp: timestamp,
          message,
        };
      }
    });
  }

  private transformToContactLog(log: any): ContactLog {
    return {
      ContactId: log.ContactId,
      ContactFlowId: log.ContactFlowId || '',
      ContactFlowName: log.ContactFlowName || '',
      ContactFlowModuleType: log.ContactFlowModuleType || '',
      Timestamp: log.Timestamp || log['@timestamp'],
      Parameters: log.Parameters,
      Results: log.Results,
      ExternalResults: log.ExternalResults,
      Identifier: log.Identifier,
    };
  }

  private transformToLambdaLog(log: any): LambdaLog {
    return {
      timestamp: log.timestamp || log['@timestamp'],
      ContactId: log.ContactId,
      service: log.service || this.extractFunctionName(log.logGroup),
      message: log.message,
      level: log.level || 'INFO',
      duration: log.duration,
      xrayTraceId: log.xrayTraceId || log['xray_trace_id'],
    };
  }

  private async streamToString(stream: any): Promise<string> {
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks).toString('utf-8');
  }

  private async streamToBuffer(stream: any): Promise<Buffer> {
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks);
  }

  private extractTimeFromKey(key: string): Date | null {
    const match = key.match(/(\d{4})-(\d{2})-(\d{2})-(\d{2})-(\d{2})-(\d{2})/);
    if (match) {
      return new Date(`${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:${match[6]}Z`);
    }
    return null;
  }

  private extractFunctionName(logGroup: string): string {
    const parts = logGroup.split('/');
    return parts[parts.length - 1];
  }

  private calculateDuration(start: Date, end?: Date): number {
    if (!end) return 0;
    return Math.floor((end.getTime() - start.getTime()) / 1000);
  }
}

// Export singleton instance
let serviceInstance: AWSConnectService | null = null;

export const getAWSConnectService = (config?: AWSConfig): AWSConnectService => {
  // If config is provided, always recreate the instance (for credential updates)
  if (config) {
    serviceInstance = new AWSConnectService(config);
  }
  if (!serviceInstance) {
    throw new Error('AWSConnectService not initialized. Please provide config.');
  }
  return serviceInstance;
};

export const resetAWSConnectService = () => {
  serviceInstance = null;
};

export default AWSConnectService;


---------------------
/Users/ke-aicc/Downloads/files/src/services/searchService.ts
---------------------
/**
 * Advanced Search Service
 *
 * Backend API를 통해 다양한 검색 기능을 제공합니다.
 */

import { AWSConfig } from '@/types/contact.types';

const API_BASE_URL = 'http://localhost:8080';

export interface SearchContact {
  contactId: string;
  channel?: string;
  initiationMethod?: string;
  initiationTimestamp?: string;
  disconnectTimestamp?: string;
  timestamp?: string;
  service?: string;
}

export interface SearchResult {
  contacts: SearchContact[];
  agentUsername?: string;
}

/**
 * Customer 검색 (Phone, Profile ID, Skypass Number)
 */
export async function searchCustomer(
  searchValue: string,
  searchType: 'phone' | 'profileId' | 'skypass',
  config: AWSConfig
): Promise<SearchResult> {
  const response = await fetch(`${API_BASE_URL}/api/search/customer`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      searchValue,
      searchType,
      credentials: config.credentials,
      region: config.region,
      environment: config.environment,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to search customer');
  }

  return response.json();
}

/**
 * Agent 검색 (UUID, Email, Name)
 */
export async function searchAgent(
  searchValue: string,
  searchType: 'uuid' | 'email' | 'name',
  config: AWSConfig
): Promise<SearchResult> {
  const response = await fetch(`${API_BASE_URL}/api/search/agent`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      searchValue,
      searchType,
      credentials: config.credentials,
      region: config.region,
      instanceId: config.instanceId,
      environment: config.environment,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to search agent');
  }

  return response.json();
}

/**
 * Contact Flow 이름으로 검색
 */
export async function searchContactFlow(
  flowName: string,
  config: AWSConfig,
  instanceAlias: string
): Promise<SearchResult> {
  const response = await fetch(`${API_BASE_URL}/api/search/contact-flow`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      flowName,
      credentials: config.credentials,
      region: config.region,
      instanceAlias,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to search contact flow');
  }

  return response.json();
}

/**
 * DNIS로 검색
 */
export async function searchDNIS(
  dnis: string,
  config: AWSConfig,
  instanceAlias: string
): Promise<SearchResult> {
  const response = await fetch(`${API_BASE_URL}/api/search/dnis`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      dnis,
      credentials: config.credentials,
      region: config.region,
      instanceAlias,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to search DNIS');
  }

  return response.json();
}

/**
 * Lambda Error 검색
 */
export async function searchLambdaError(
  config: AWSConfig
): Promise<SearchResult> {
  const response = await fetch(`${API_BASE_URL}/api/search/lambda-error`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      credentials: config.credentials,
      region: config.region,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Failed to search lambda errors');
  }

  return response.json();
}

/**
 * 검색 값에서 검색 타입 감지
 */
export function detectSearchType(searchValue: string, searchCategory: string): string {
  if (searchCategory === 'Customer') {
    // E.164 phone number
    if (/^\+[1-9][0-9]{7,14}$/.test(searchValue)) {
      return 'phone';
    }
    // 32-char profile ID
    if (/^[a-zA-Z0-9]{32}$/.test(searchValue)) {
      return 'profileId';
    }
    // 12-char skypass number
    if (/^[a-zA-Z0-9]{12}$/.test(searchValue)) {
      return 'skypass';
    }
  } else if (searchCategory === 'Agent') {
    // UUID
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(searchValue)) {
      return 'uuid';
    }
    // Email
    if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(searchValue)) {
      return 'email';
    }
    // Name
    return 'name';
  }

  return 'unknown';
}


